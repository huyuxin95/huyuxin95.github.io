<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Huyuxin's Blog" />










<meta name="description" content="打渔还是晒网,这是一个问题">
<meta property="og:type" content="website">
<meta property="og:title" content="Huyuxin&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Huyuxin&#39;s Blog">
<meta property="og:description" content="打渔还是晒网,这是一个问题">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Huyuxin&#39;s Blog">
<meta name="twitter:description" content="打渔还是晒网,这是一个问题">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Huyuxin's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Huyuxin's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/06/java-thread-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/06/java-thread-one/" itemprop="url">Java多线程(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-06T00:11:21+08:00">
                2017-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>突然整理这篇博客是同事碰到个多线程的问题，问我可我没回答上来。java多线程是面试必问，也是一个讲不完的话题，下面是一些我整理的知识点。加油！</p>
</blockquote>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程和线程都是系统的调度单位，但是相对于进程，线程则是系统调度的最小单位。对于一个程序来说，一个程序存在一个进程，但是可以存在多个线程，当进程结束，那么依赖他的线程也将全部结束。反之则不然。</p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>在java中创建线程的方式主要有三种，先讲常用的两种:</p>
<p>1.继承Thread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package top.huyuxin.thread;</span><br><span class="line">public class Exthread extends Thread&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	public Exthread(String name) &#123;</span><br><span class="line">		super(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		super.run();</span><br><span class="line">		System.out.println(&quot;name:&quot;+Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exthread exthread=new Exthread(&quot;exthread&quot;);</span><br><span class="line">exthread.start();</span><br></pre></td></tr></table></figure>
<p>通过继承Thread类来创建线程，我们重写了他的其中一个构造，用来传递当前线程的名字进来，在执行的时候将其打印。（很多新手会直接使用线程的对象来调用run方法来开启线程这是错误的方式，Thread再神秘他也是一个类，通过类对象调用方法，那么他是不会新建一个线程的。）</p>
<p>2.实现Runnable接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package top.huyuxin.thread;</span><br><span class="line"></span><br><span class="line">public class Imrunable  implements Runnable&#123;</span><br><span class="line">	</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public Imrunable(String name) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.name=name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;name:&quot;+name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然即使实现了Runable，他也还只还是一个实现Runable的类而已，开启线程还是需要依赖Thread的另一个构造器来生成Thread对象来开启线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Imrunable imrunable=new Imrunable(&quot;imthread&quot;);</span><br><span class="line">Thread imThread=new Thread(imrunable);</span><br><span class="line">imThread.start();</span><br></pre></td></tr></table></figure></p>
<p>3.实现Callable接口<br>当初别人跟我说第三种方法时候，我说还有这种操作？我在Thread的构造中没见过啊<br><img src="http://img.blog.csdn.net/20170903222622874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>然后他给我看了实现过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line">public class Imcallable implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	public Imcallable(String name) &#123;</span><br><span class="line">		this.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String call() throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;name:&quot;+name);</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Imcallable imcallable=new Imcallable(&quot;imcallable&quot;);</span><br><span class="line">FutureTask&lt;String&gt; futureTask=new FutureTask&lt;&gt;(imcallable);</span><br><span class="line">Thread thread=new Thread(futureTask);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<p>我又纳闷了Thread的构造也没传 FutureTask&lt; V&gt;这个的构造啊。<br>看了 FutureTask&lt; V&gt;这个类的源码才发现他实现了RunnableFuture&lt; V&gt;这个接口，而RunnableFuture&lt; V&gt;有继承了两个接口Runnable，Future&lt; V&gt;（extend用于类只能是单继承，用于接口可多继承）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;</span><br><span class="line">//省略实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     */</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以实现Callable接口的方法用的是<code>Thread(Runnable target)</code>这个构造器。</p>
<p><strong><em><font color="#ff0000">需要注意的是：Java中的多线程是一种抢占机制而不是分时机制。抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。</font></em></strong></p>
<h2 id="线程的状态（State）："><a href="#线程的状态（State）：" class="headerlink" title="线程的状态（State）："></a>线程的状态（State）：</h2><p>java的源码将其分为六种状态，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Thread已经被new但是还没有启动也就是还没调用start（）</span><br><span class="line">     */</span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 就绪状态，已经执行了start，但是还在等待CPU资源，还没被运行</span><br><span class="line">     */</span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 阻塞状态，线程没有获取到对象锁，一个线程处于阻塞态，</span><br><span class="line">     * 那么他在等待对象锁来进入或重入被synchronized修饰的</span><br><span class="line">     * 代码块或则是方法</span><br><span class="line">     */</span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 一个线程处于等待状态，那么他可能是因为调用了Object.wait()</span><br><span class="line">     * 或则是Thread.join（），也可能是LockSupport.park（）</span><br><span class="line">     * 一个线程处于等待状态是在等待另一个线程执行特定的动作</span><br><span class="line">     * 比如一个线程调用了Object.wait()处于等待状态，那么他在等</span><br><span class="line">     * 另一个线程执行Object.notify()或则Object.notifyAll()</span><br><span class="line">     * （注意的是应该是同一个对象的wait()和notify()，notifyAll()方法）</span><br><span class="line">     * 或则是一个线程内执行了Thread.join()那么当前线程将处于等待 </span><br><span class="line">     *  状态直到调用join的线程执行完毕         </span><br><span class="line">     */</span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 等待状态，这个等待状态是在等待一个特定的时机</span><br><span class="line">     * 当调用下面的方法将进入TIMED_WAITING状态</span><br><span class="line">     * Thread.sleep（），</span><br><span class="line">     * Object.wait(long) Object.wait()</span><br><span class="line">     * Thread.join(long) Thread.join()</span><br><span class="line">     * LockSupport.parkNanos()</span><br><span class="line">     * LockSupport.parkUntil()</span><br><span class="line">     */</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 结束状态，一个线程执行完毕</span><br><span class="line">     */</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们为了更好理解，一般都将其分为以下五种状态，将WAITING和TIMED_WAITING合二为一：</p>
<p>　　</p>
<ul>
<li><p>新生状态（New）：</p>
<p>当一个线程的实例被创建即使用new关键字和Thread类或其子类创建一个线程对象后，此时该线程处于新生(new)状态，处于新生状态的线程有自己的内存空间，但该线程并没有运行，此时线程还不是活着的（not alive）；</p>
</li>
</ul>
<p>　　</p>
<ul>
<li><p>就绪状态（Runnable）：</p>
<p>通过调用线程实例的start()方法来启动线程使线程进入就绪状态(runnable)；处于就绪状态的线程已经具备了运行条件，但还没有被分配到CPU即不一定会被立即执行，此时处于线程就绪队列，等待系统为其分配CPCU，等待状态并不是执行状态； 此时线程是活着的（alive）；</p>
</li>
</ul>
<p>　　</p>
<ul>
<li><p>运行状态（Running）：</p>
<p>一旦获取CPU(被JVM选中)，线程就进入运行(running)状态，线程的run()方法才开始被执行；在运行状态的线程执行自己的run()方法中的操作，直到调用其他的方法而终止、或者等待某种资源而阻塞、或者完成任务而死亡；如果在给定的时间片内没有执行结束，就会被系统给换下来回到线程的等待状态；此时线程是活着的（alive）；</p>
</li>
<li><p>阻塞状态（Blocked）：</p>
<p> 通过调用join()、sleep()、wait()或者资源被暂用使线程处于阻塞(blocked)状态；处于Blocking状态的线程仍然是活着的（alive）</p>
</li>
<li><p>死亡状态（Dead）：</p>
<p> 当一个线程的run()方法运行完毕或被中断或被异常退出，该线程到达死亡(dead)状态。此时可能仍然存在一个该Thread的实例对象，当该Thready已经不可能在被作为一个可被独立执行的线程对待了，线程的独立的call stack已经被dissolved。一旦某一线程进入Dead状态，他就再也不能进入一个独立线程的生命周期了。对于一个处于Dead状态的线程调用start()方法，会出现一个运行期(runtime exception)的异常；处于Dead状态的线程不是活着的（not alive）。</p>
<h2 id="线程的方法（Method）、属性（Property）"><a href="#线程的方法（Method）、属性（Property）" class="headerlink" title="线程的方法（Method）、属性（Property） "></a>线程的方法（Method）、属性（Property） </h2><p><strong>1）优先级（priority）</strong></p>
</li>
</ul>
<p>每个类都有自己的优先级，一般property用1-10的整数表示，默认优先级是5，优先级最高是10；优先级高的线程并不一定比优先级低的线程执行的机会高，<strong>只是执行的机率高</strong>；默认一个线程的优先级和创建他的线程优先级相同；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * The minimum priority that a thread can have.</span><br><span class="line">     */</span><br><span class="line">    public final static int MIN_PRIORITY = 1;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">     * The default priority that is assigned to a thread.</span><br><span class="line">     */</span><br><span class="line">    public final static int NORM_PRIORITY = 5;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The maximum priority that a thread can have.</span><br><span class="line">     */</span><br><span class="line">    public final static int MAX_PRIORITY = 10;</span><br><span class="line">    //从Thread的init方法里可以看出，新创建的线程没有配置属性的话</span><br><span class="line">    //那他的优先级将和创建时所在的线程保持一致</span><br><span class="line"> private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                      long stackSize, AccessControlContext acc) &#123;</span><br><span class="line">        this.group = g;</span><br><span class="line">        this.daemon = parent.isDaemon();</span><br><span class="line">        this.priority = parent.getPriority();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）Thread.sleep()/sleep(long millis)</strong></p>
<p>当前线程睡眠/millis的时间（millis指定睡眠时间是其最小的不执行时间，由于java的多线程是抢占机制，sleep(millis)休眠到达后，无法保证会被JVM立即调度）；sleep()是一个静态方法(static method) ，睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，所以他不会使得其他的线程也处于休眠状态；线程sleep()时不会失去拥有的对象锁。<br> 作用：<strong><font color="#ff0000">保持对象锁</font></strong>，让出CPU，调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留一定的时间给其他线程执行的机会；</p>
<p><strong>3）Thread.yield()</strong></p>
<p>  让出CPU的使用权，给其他线程执行机会、<strong>让同等优先权的线程运行</strong>（但并不保证当前线程不会被JVM再次调度、使该线程重新进入Running状态），<strong>如果没有同等优先权的线程，那么yield()方法将不会起作用。</strong></p>
<p><strong>4）thread.join()</strong></p>
<p>在一个线程里，另一个线程调用join方法，那么<strong>所在的这个线程</strong>将进入阻塞态，直到另一个线程执行完毕。</p>
<p><strong>5）object.wait()</strong></p>
<p>  当一个线程执行到wait()方法时，他就进入到一个<strong>和该对象</strong>相关的等待池(Waiting Pool)中，同时<strong><font color="#ff0000">失去对象锁</font></strong>—暂时的，wait后还要返还对象锁。当前线程必须拥有当前对象的锁，如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常,所以wait()必须在synchronized block中调用。并且notify()和notifyAll()必须在具有调用wait()相同的对象锁的synchronized block中调用。</p>
<p><strong>6）object.notify()/notifyAll()</strong></p>
<p>  唤醒在当前对象等待池中等待的第一个线程/所有线程。notify()/notifyAll()也必须拥有相同对象锁，否则也会抛出IllegalMonitorStateException异常。当多个线程被阻塞notify()的第一个线程将是一个随机线程，notifyAll()则会将全部阻塞线程唤醒，至于哪个线程进入运行态则不得而知。<br>  <strong>7）thread.setDaemon(boolean on)</strong><br>在创建线程时如果当前线程是守护线程，那么创建的子线程默认也是守护进程，当进程结束，那么他的守护进程不管是否已经结束都将被销毁。<br>设置某个线程为守护线程时，应该在其调用start()之前。否则将抛出异常  IllegalThreadStateException，。守护线的好处就是你不需要关心它的结束问题。当主线程结束他也将结束。</p>
<p>  <strong>8）Synchronized</strong><br>Synchronized 可以修饰代码块，方法，静态方法，类.</p>
<ul>
<li>当修饰代码块时当前Thread持有的对象锁是传入的形参obj  <code>synchronized （Obejct obj）</code></li>
<li>当修饰方法时，当前Thread持有的对象锁是调用方法的对象等同于<code>synchronized(this)</code></li>
<li>当修饰静态方法时，等同于   <code>synchronized(Object.class)</code></li>
<li>当修饰类时，这个类所有的方法都等同于被   synchronized修饰</li>
</ul>
<p>每个Synchronized Block/方法只有持有调用该方法被锁定对象的锁才可以访问，否则所属线程阻塞；机锁具有独占性、一旦被一个Thread持有，其他的Thread就不能再拥有（不能访问其他同步方法），方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。</p>
<h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>在上面提到了很多次的对象锁，那么对象锁到底是什么呢？这就要说到java的monitor了<br>synchronized, wait, notify 是任何对象都具有的同步工具。</p>
<p>他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器/对象锁，来监测并发代码的重入。在非多线程编码时该对象锁不发挥作用，反之如果在synchronized 范围内，对象锁发挥作用。</p>
<p>wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个对象锁（某对象的对象锁）。这意味着wait（暂时失去对象锁）之后，其他线程可以进入同步块执行。</p>
<p>当某代码并不持有对象锁的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的对象锁不同，同样会抛出此异常。<br><img src="http://img.blog.csdn.net/20170904000711186?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>那么如果在拥有对象锁的代码块里再次执行需要当前对象锁时能否进入呢？答案是肯定的，每一次重入相同对象锁的代码monitor的计数器将+1，退出时计数器将-1，当计数器为0时则完全释放了这个对象锁。</p>
<h2 id="正确结束线程"><a href="#正确结束线程" class="headerlink" title="正确结束线程"></a>正确结束线程</h2><p>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！（突然的结束这将使得对象锁的状态不可控）想要安全有效的结束一个线程，可以使用下面的方法：</p>
<pre><code>• 正常执行完run方法，然后自然的结束掉；

• 控制循环条件和判断条件的标识符来结束掉线程。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i=0;  </span><br><span class="line">    boolean next=true;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (next) &#123;  </span><br><span class="line">            if(i==10)  </span><br><span class="line">                next=false;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过标志位来结束线程使用起来十分简单的方法。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>在多线程并发的时候对于同一资源操作，数据变得十分不可靠。加入对象锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。<br><strong>1、synchronized</strong><br>即有synchronized关键字修饰的方法。由于java的每个对象都有一个对象锁，当用此关键字修饰方法时，对象锁会保护整个方法。在调用该方法前，需要获得对象锁，否则就处于阻塞状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void save()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这与所持有的锁是一致的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void save()&#123;</span><br><span class="line">synchronized(this)&#123;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当synchronized修饰静态方法时，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void save()&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>他持有的锁等同于当前类的class对象，他将会锁住整个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void save()&#123;</span><br><span class="line">synchronized(Object.class)&#123;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当synchronized修饰类时，那么等同于这个类所有的方法都被synchronized修饰。<br>同步是一个开销很高的操作因为对象锁是一个互斥锁，当一个线程得到了，别的线程想要访问将处于阻塞状态。直到已获取对象锁的线程释放才有机会获得。相对于同步方法，同步代码块是一个相对能够接受的方式。</p>
<p><strong>2.volatile</strong></p>
<blockquote>
<p>线程栈<br>线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。</p>
</blockquote>
<p>多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。<br><img src="http://img.blog.csdn.net/20170904221820658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。<br><strong>3.原子类</strong><br>   java提供的原子操作可以原子更新的<br>   基本类型有以下三个：<br>      AtomicBoolean<br>      AtomicInteger<br>      AtomicLong<br>  原子更新数组，Atomic包提供了以下几个类：<br>  AtomicIntegerArray<br>  AtomicLongArray<br>  AtomicReferenceArray<br>  原子更新引用类型，也就是更新实体类的值，比如：<br>AtomicReference:原子更新引用类型的值<br>  AtomicReferenceFieldUpdater:原子更新引用类型里的字段<br> AtomicMarkableReference:原子更新带有标记位的引用类型<br>原子更新字段值：<br>AtomicIntegerFieldUpdater:原子更新整形的字段的更新器<br>AtomicLongFieldUpdater:原子更新长整形的字段的更新器<br> AtomicStampedReference:原子更新带有版本号的引用类型的更新器<br>那这些原子类是怎样实现原子操作的呢？可以拿AtomicInteger的getAndIncrement()方法实现来说明，看方法名就知道函数的功能了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public final int getAndIncrement() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">              int current = get();  // 取得AtomicInteger里存储的数值</span><br><span class="line">       int next = current + 1;  // 加1</span><br><span class="line">         if (compareAndSet(current, next))   // 调用compareAndSet执行原子更新操作</span><br><span class="line">                return current;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他在里面写了个死循环然后不断的获取自己的值，直到获取的当前值相等执行set操作并return跳出死循环。</p>
<p><strong>4、使用重入锁（Lock）实现线程同步</strong><br>     在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有：</p>
<ul>
<li><p>ReentrantLock() : 创建一个ReentrantLock实例</p>
</li>
<li><p>lock() : 获得锁</p>
</li>
<li><p>unlock() : 释放锁</p>
</li>
</ul>
<p>这个重入锁是synchronized的加强版！使用也十分的方便。并且加入了锁投票、定时锁等候和可中断锁等候的一些特性等待你去发掘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Bank &#123;</span><br><span class="line">    </span><br><span class="line">    private int account = 100;</span><br><span class="line">    //通过new创建一个锁的对象</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    public int getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line">    //这里不再需要synchronized </span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">    //在需要同步的代码前面调用lock()方法</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            account += money;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">        //为了防止同步的代码块中出现异常，所以在finally中将锁释放</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>1、借助于Object类的wait()、notify()和notifyAll()实现通信</p>
<p>线程执行wait()后，就放弃了运行资格，处于冻结状态；线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。<br>      notifyall(), 唤醒线程池中所有线程。</p>
<blockquote>
<p>注： （1） wait(),notify(),notifyall()都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；</p>
<p> 2） wait(),notify(),notifyall(),  在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package top.huyuxin.thread;</span><br><span class="line"></span><br><span class="line">public class Resource &#123;</span><br><span class="line">	private int count = 0;</span><br><span class="line">	private static boolean flag = false;</span><br><span class="line"></span><br><span class="line">	public synchronized void add() &#123;</span><br><span class="line">		if(flag)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				this.wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		count+=1;</span><br><span class="line">		System.out.println(&quot;after add:&quot;+count);</span><br><span class="line">		flag=true;</span><br><span class="line">		this.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public synchronized void sub() &#123;</span><br><span class="line">		if(!flag)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				this.wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		count-=1;</span><br><span class="line">		System.out.println(&quot;after sub:&quot;+count);</span><br><span class="line">		flag=false;</span><br><span class="line">		this.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package top.huyuxin.thread;</span><br><span class="line"></span><br><span class="line">public class SyncAddThread extends Thread&#123;</span><br><span class="line">	</span><br><span class="line">	private Resource res;</span><br><span class="line">	</span><br><span class="line">	public SyncAddThread(Resource res) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.res = res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		super.run();</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			res.add();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package top.huyuxin.thread;</span><br><span class="line"></span><br><span class="line">public class SyncSubThread extends Thread &#123;</span><br><span class="line">	</span><br><span class="line">	private Resource res;</span><br><span class="line"></span><br><span class="line">	public SyncSubThread(Resource res) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.res = res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		super.run();</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			res.sub();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用过程中他们相互唤醒，轮流运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Resource resource =new Resource();</span><br><span class="line">SyncSubThread syncSubThread =new SyncSubThread(resource);</span><br><span class="line">SyncAddThread syncAddThread =new SyncAddThread(resource);</span><br><span class="line">syncSubThread.start();</span><br><span class="line">syncAddThread.start();</span><br></pre></td></tr></table></figure></p>
<p>2、使用Condition控制线程通信<br>jdk1.5中，提供了多线程的升级解决方案为：</p>
<ul>
<li>（1）将同步synchronized替换为显式的Lock操作；</li>
<li>（2）将Object类中的wait(), notify(),notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取;</li>
<li>（3）一个Lock对象上可以绑定多个Condition对象，唤醒指定的线程，而jdk1.5之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。</li>
</ul>
<p>将上面Resouce类修改一番，其中Condition类的等待方法是await(),唤醒方法是signal(),signalAll()，其中Condition的对象是从当前lock中获取而不是通过new。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package top.huyuxin.thread;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Resource &#123;</span><br><span class="line">	private int count = 1;</span><br><span class="line">	private static boolean flag = false;</span><br><span class="line">	private Lock lock = new ReentrantLock();</span><br><span class="line">	private Condition condition_add = lock.newCondition();</span><br><span class="line">	private Condition condition_sub = lock.newCondition();</span><br><span class="line">	private Condition condition_mul = lock.newCondition();</span><br><span class="line"></span><br><span class="line">	public void add() &#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		try &#123;</span><br><span class="line">			if (flag) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					condition_add.await();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			count += 1;</span><br><span class="line">			System.out.println(&quot;after add:&quot; + count);</span><br><span class="line">			flag = true;</span><br><span class="line">			condition_mul.signal();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public  void sub() &#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		try&#123;</span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				condition_sub.await();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		count -= 1;</span><br><span class="line">		System.out.println(&quot;after sub:&quot; + count);</span><br><span class="line">		flag = false;</span><br><span class="line">		condition_add.signal();</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public  void mul() &#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		try&#123;</span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				condition_mul.await();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		count =count*2;</span><br><span class="line">		System.out.println(&quot;after mul:&quot; + count);</span><br><span class="line">		flag = false;</span><br><span class="line">		condition_sub.signal();</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们启动三个线程，他们会相互唤醒，add唤醒mul，mul唤醒sub，sub唤醒add，依次循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Resource resource =new Resource();</span><br><span class="line">SyncSubThread syncSubThread =new SyncSubThread(resource);</span><br><span class="line">SyncAddThread syncAddThread =new SyncAddThread(resource);</span><br><span class="line">SyncMulThread syncMulThread =new SyncMulThread(resource);</span><br><span class="line">syncSubThread.start();</span><br><span class="line">syncAddThread.start();</span><br><span class="line">syncMulThread.start();</span><br></pre></td></tr></table></figure></p>
<p>使用阻塞队列（BlockingQueue）控制线程通信</p>
<pre><code>BlockingQueue是一个接口，也是Queue的子接口。BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从BlockingQueue中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。
</code></pre><p>3.BlockingQueue提供如下两个支持阻塞的方法：</p>
<ul>
<li>（1）put(E e)：尝试把Eu元素放如BlockingQueue中，如果该队列的元素已满，则阻塞当前放置操作的线程。</li>
<li>（2）take（）：尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞当前获取操作的线程。</li>
</ul>
<p>BlockingQueue继承了Queue接口，当然也可以使用Queue接口中的方法，这些方法归纳起来可以分为如下三组：</p>
<p>  （1）在队列尾部插入元素，包括add（E e）、offer（E e）、put（E e）方法，当该队列已满时，这三个方法分别会抛出异常、返回false、阻塞队列。</p>
<p>  （2）在队列头部删除并返回删除的元素。包括remove（）、poll（）、和take（）方法，当该队列已空时，这三个方法分别会抛出异常、返回false、阻塞队列。</p>
<p>  （3）在队列头部取出但不删除元素。包括element（）和peek（）方法，当队列已空时，这两个方法分别抛出异常、返回false。</p>
<p>BlockingQueue接口包含如下5个实现类：</p>
<ul>
<li>ArrayBlockingQueue ：基于数组实现的BlockingQueue队列。</li>
<li>LinkedBlockingQueue：基于链表实现的BlockingQueue队列。</li>
<li>PriorityBlockingQueue：它并不是保准的阻塞队列，该队列调用remove（）、poll（）、take（）等方法提取出元素时，并不是取出队列中存在时间最长的元素，而是队列中最小的元素。<pre><code>它判断元素的大小即可根据元素（实现Comparable接口）的本身大小来自然排序，也可使用Comparator进行定制排序。
</code></pre></li>
<li>SynchronousQueue：同步队列。对该队列的存、取操作必须交替进行。</li>
<li>DelayQueue：它是一个特殊的BlockingQueue，底层基于PriorityBlockingQueue实现，不过，DelayQueue要求集合元素都实现Delay接口（该接口里只有一个long  getDelay（）方法）， DelayQueue根据集合元素的getDalay（）方法的返回值进行排序。<br>看下ArrayBlockingQueue的构造，原来也是使用newCondition实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">public class BlockingQueueTest&#123;</span><br><span class="line">    public static void main(String[] args)throws Exception&#123;</span><br><span class="line">        //创建一个容量为 1 的BlockingQueue</span><br><span class="line">        </span><br><span class="line">        BlockingQueue&lt;String&gt; b=new ArrayBlockingQueue&lt;&gt;(1);</span><br><span class="line">        //启动3个生产者线程</span><br><span class="line">        new Producer(b).start();</span><br><span class="line">        new Producer(b).start();</span><br><span class="line">        new Producer(b).start();</span><br><span class="line">        //启动一个消费者线程</span><br><span class="line">        new Consumer(b).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Producer extends Thread&#123;</span><br><span class="line">    private BlockingQueue&lt;String&gt; b;</span><br><span class="line">    </span><br><span class="line">    public Producer(BlockingQueue&lt;String&gt; b)&#123;</span><br><span class="line">        this.b=b;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void run()&#123;</span><br><span class="line">        String [] str=new String[]&#123;</span><br><span class="line">            &quot;java&quot;,</span><br><span class="line">            &quot;struts&quot;,</span><br><span class="line">            &quot;Spring&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        for(int i=0;i&lt;9999999;i++)&#123;</span><br><span class="line">            System.out.println(getName()+&quot;生产者准备生产集合元素！&quot;);</span><br><span class="line">            try&#123;</span><br><span class="line">            </span><br><span class="line">                b.put(str[i%3]);</span><br><span class="line">                sleep(1000);</span><br><span class="line">                //尝试放入元素，如果队列已满，则线程被阻塞</span><br><span class="line">                </span><br><span class="line">            &#125;catch(Exception e)&#123;System.out.println(e);&#125;</span><br><span class="line">            System.out.println(getName()+&quot;生产完成：&quot;+b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Consumer extends Thread&#123;</span><br><span class="line">    private BlockingQueue&lt;String&gt; b;</span><br><span class="line">    public Consumer(BlockingQueue&lt;String&gt; b)&#123;</span><br><span class="line">        this.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    public  synchronized  void run()&#123;</span><br><span class="line">    </span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(getName()+&quot;消费者准备消费集合元素！&quot;);</span><br><span class="line">            try&#123;</span><br><span class="line">                sleep(1000);</span><br><span class="line">                //尝试取出元素，如果队列已空，则线程被阻塞</span><br><span class="line">                b.take();</span><br><span class="line">            &#125;catch(Exception e)&#123;System.out.println(e);&#125;</span><br><span class="line">            System.out.println(getName()+&quot;消费完：&quot;+b);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内容有点多，下篇整理线程池以及线程相关的类ThreadLocal，ThreadGroup等</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/19/apk-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/19/apk-shell/" itemprop="url">Apk源码的加固(加壳)原理解析和实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-19T00:30:04+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好久没写博客了，要深刻检讨下！</span><br></pre></td></tr></table></figure>
<p>前言：<br>在Android中没有经过加密的Apk给人的感觉就是在裸奔，通过apktool,dex2jar,AndroidKill等各式各样的反编译工具就可以轻松的获取其smail代码，如这个叫SourceProject的helloworld程序被apktool反编译后，对于懂smail语法的逆向工程师来说就一览无余了。破解与反破解是相对的，所以我们尽可能的给自己的Apk多穿点衣服。<br><img src="http://img.blog.csdn.net/20170618214840263?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>首先我们先来看下Apk加壳的步骤：<br><img src="http://img.blog.csdn.net/20170618215110845?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ul>
<li>源Apk：需要加壳的Apk</li>
<li>加密的Apk：源Apk经过加密算法加密后的Apk</li>
<li>加壳程序Apk：是有解密源Apk和动态加载启动源Apk的外壳</li>
</ul>
<p>首先我们拿到需要加壳的源Apk，通过加密算法加密源Apk然后与加壳Apk的dex文件组合成新的Dex文件，然后将加壳程序Apk的Dex文件替换成新的Dex，生成新的Apk重新签名。<br>我们先来看下Dex文件的结构：<br><img src="http://img.blog.csdn.net/20170618220105113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ul>
<li>Magic<br>Magic数是为了方便虚拟机识别目标文件是否是合格的Dex文件，在Dex文件中magic的值固定值</li>
<li>checksum<br>文件校验码 ，使用alder32 算法校验文件除去 maigc ，checksum 外余下的所有文件区域 ，用于检查文件错误 </li>
<li>signature<br>使用 SHA-1 算法 hash 除去 magic ,checksum 和 signature 外余下的所有文件区域 ，用于唯一识别本文件 。</li>
<li>file_size<br>当前Dex 文件的大小 。</li>
</ul>
<p>所以我们在将Dex与加密算法加密后的Apk合并生成新的Dex后需要修改新Dex文件的这三个值，为了方便从新Dex中获得加密的Apk，我们需要知道加密的Apk的大小，为了方便以后获得，我们将其大小放置在新Dex的后四位，新生成的Dex文件结构：<br><img src="http://img.blog.csdn.net/20170618222517688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>生成新Dex后，将加壳程序Apk的Dex文件替换，重新签名后加壳的Apk即完成了。如果觉得步骤理清了，我们来看下其具体的实现。</p>
<hr>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><p>这过程一共要创建三个项目。<br>首先我们先创建一个需要加密的Apk项目，结构非常简单只有几个Log的打印，结构<br><img src="http://img.blog.csdn.net/20170618225136910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>SourceApplication.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.jju.yuxin.sourceproject;</span><br><span class="line">import android.app.Application;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">public class SourceApplication extends Application &#123;</span><br><span class="line">    private static final String TAG=SourceApplication.class.getSimpleName();</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        Log.d(TAG,&quot;-------------onCreate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainActivity.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.jju.yuxin.sourceproject;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    private static final String TAG=MainActivity.class.getSimpleName();</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        TextView tv_content = new TextView(this);</span><br><span class="line">        tv_content.setText(&quot;I am Source Apk&quot;);</span><br><span class="line">        tv_content.setOnClickListener(new View.OnClickListener()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View arg0) &#123;</span><br><span class="line">                Intent intent = new Intent(MainActivity.this, SubActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">        setContentView(tv_content);</span><br><span class="line">        Log.i(TAG, &quot;onCreate：app:&quot;+getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubActivity.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.jju.yuxin.sourceproject;</span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">public class SubActivity extends Activity &#123;</span><br><span class="line">    private static final String TAG=SubActivity.class.getSimpleName();</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        TextView tv_content = new TextView(this);</span><br><span class="line">        tv_content.setText(&quot;I am SubActivity&quot;);</span><br><span class="line">        setContentView(tv_content);</span><br><span class="line">        Log.i(TAG, &quot;SubActivity：app:&quot;+getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将其打包生成Apk。<br>第二个项目是一个JAVA项目用于将源Apk加密，并合并加壳程序Dex与加密后的源Apk。在贴出这个代码时我们先不用管加壳程序Dex从何而来，假设已经有了这样一个文件。我们来看下具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">package com.forceapk;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;  </span><br><span class="line">import java.io.File;  </span><br><span class="line">import java.io.FileInputStream;  </span><br><span class="line">import java.io.FileOutputStream;  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">import java.security.MessageDigest;  </span><br><span class="line">import java.security.NoSuchAlgorithmException;  </span><br><span class="line">import java.util.zip.Adler32;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">public class mymain &#123; </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">        	//需要加壳的源APK  ，以二进制形式读出，并进行加密处理</span><br><span class="line">            File srcApkFile = new File(&quot;force/SourceAPK.apk&quot;);   </span><br><span class="line">            System.out.println(&quot;apk size:&quot;+srcApkFile.length()); </span><br><span class="line">            byte[] enSrcApkArray = encrpt(readFileBytes(srcApkFile));</span><br><span class="line">            </span><br><span class="line">            //需要解壳的dex  以二进制形式读出dex  </span><br><span class="line">            File unShellDexFile = new File(&quot;force/shelldex.dex&quot;);    </span><br><span class="line">            byte[] unShellDexArray = readFileBytes(unShellDexFile);</span><br><span class="line"></span><br><span class="line">            //将源APK长度和需要解壳的DEX长度相加并加上存放源APK大小的四位得到总长度</span><br><span class="line">            int enSrcApkLen = enSrcApkArray.length;  </span><br><span class="line">            int unShellDexLen = unShellDexArray.length;  </span><br><span class="line">            int totalLen = enSrcApkLen + unShellDexLen +4;</span><br><span class="line">            </span><br><span class="line">            //依次将解壳DEX，加密后的源APK，加密后的源APK大小，拼接出新的Dex</span><br><span class="line">            byte[] newdex = new byte[totalLen];  </span><br><span class="line">            System.arraycopy(unShellDexArray, 0, newdex, 0, unShellDexLen);</span><br><span class="line">            System.arraycopy(enSrcApkArray, 0, newdex, unShellDexLen, enSrcApkLen);</span><br><span class="line">            System.arraycopy(intToByte(enSrcApkLen), 0, newdex, totalLen-4, 4);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            //修改DEX file size文件头  </span><br><span class="line">            fixFileSizeHeader(newdex);  </span><br><span class="line">            //修改DEX SHA1 文件头  </span><br><span class="line">            fixSHA1Header(newdex);  </span><br><span class="line">            //修改DEX CheckSum文件头  </span><br><span class="line">            fixCheckSumHeader(newdex);  </span><br><span class="line">  </span><br><span class="line">            //写出</span><br><span class="line">            String str = &quot;force/classes.dex&quot;;  </span><br><span class="line">            File file = new File(str);  </span><br><span class="line">            if (!file.exists()) &#123;  </span><br><span class="line">                file.createNewFile();  </span><br><span class="line">            &#125;  </span><br><span class="line">            FileOutputStream localFileOutputStream = new FileOutputStream(str);  </span><br><span class="line">            localFileOutputStream.write(newdex);  </span><br><span class="line">            localFileOutputStream.flush();  </span><br><span class="line">            localFileOutputStream.close();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    //可以修改成自己的加密方法  </span><br><span class="line">    private static byte[] encrpt(byte[] srcdata)&#123;  </span><br><span class="line">        for(int i = 0;i&lt;srcdata.length;i++)&#123;  </span><br><span class="line">            srcdata[i] = (byte)(0xFF ^ srcdata[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return srcdata;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 修改dex头，CheckSum 校验码 </span><br><span class="line">     * @param dexBytes </span><br><span class="line">     */  </span><br><span class="line">    private static void fixCheckSumHeader(byte[] dexBytes) &#123;  </span><br><span class="line">        Adler32 adler = new Adler32();  </span><br><span class="line">        adler.update(dexBytes, 12, dexBytes.length - 12);//从12到文件末尾计算校验码  </span><br><span class="line">        long value = adler.getValue();  </span><br><span class="line">        int va = (int) value;  </span><br><span class="line">        byte[] newcs = intToByte(va);  </span><br><span class="line">        //高位在前，低位在前掉个个  </span><br><span class="line">        byte[] recs = new byte[4];  </span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">            recs[i] = newcs[newcs.length - 1 - i];  </span><br><span class="line">            System.out.println(Integer.toHexString(newcs[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.arraycopy(recs, 0, dexBytes, 8, 4);//效验码赋值（8-11）  </span><br><span class="line">        System.out.println(Long.toHexString(value));  </span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * int 转byte[] </span><br><span class="line">     * @param number </span><br><span class="line">     * @return </span><br><span class="line">     */  </span><br><span class="line">    public static byte[] intToByte(int number) &#123;  </span><br><span class="line">        byte[] b = new byte[4];  </span><br><span class="line">        for (int i = 3; i &gt;= 0; i--) &#123;  </span><br><span class="line">            b[i] = (byte) (number % 256);  </span><br><span class="line">            number &gt;&gt;= 8;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return b;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 修改dex头 sha1值 </span><br><span class="line">     * @param dexBytes </span><br><span class="line">     * @throws NoSuchAlgorithmException </span><br><span class="line">     */  </span><br><span class="line">    private static void fixSHA1Header(byte[] dexBytes)  </span><br><span class="line">            throws NoSuchAlgorithmException &#123;  </span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;);  </span><br><span class="line">        md.update(dexBytes, 32, dexBytes.length - 32);//从32为到结束计算sha--1  </span><br><span class="line">        byte[] newdt = md.digest();  </span><br><span class="line">        System.arraycopy(newdt, 0, dexBytes, 12, 20);//修改sha-1值（12-31）  </span><br><span class="line">        //输出sha-1值，可有可无  </span><br><span class="line">        String hexstr = &quot;&quot;;  </span><br><span class="line">        for (int i = 0; i &lt; newdt.length; i++) &#123;  </span><br><span class="line">            hexstr += Integer.toString((newdt[i] &amp; 0xff) + 0x100, 16)  </span><br><span class="line">                    .substring(1);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(hexstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 修改dex头 file_size值 </span><br><span class="line">     * @param dexBytes </span><br><span class="line">     */  </span><br><span class="line">    private static void fixFileSizeHeader(byte[] dexBytes) &#123;  </span><br><span class="line">        //新文件长度  </span><br><span class="line">        byte[] newfs = intToByte(dexBytes.length);  </span><br><span class="line">        System.out.println(Integer.toHexString(dexBytes.length));  </span><br><span class="line">        byte[] refs = new byte[4];  </span><br><span class="line">        //高位在前，低位在前掉个个  </span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">            refs[i] = newfs[newfs.length - 1 - i];  </span><br><span class="line">            System.out.println(Integer.toHexString(newfs[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.arraycopy(refs, 0, dexBytes, 32, 4);//修改（32-35）  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 以二进制读出文件内容 </span><br><span class="line">     * @param file </span><br><span class="line">     * @return </span><br><span class="line">     * @throws IOException </span><br><span class="line">     */  </span><br><span class="line">    private static byte[] readFileBytes(File file) throws IOException &#123;  </span><br><span class="line">        byte[] arrayOfByte = new byte[1024];  </span><br><span class="line">        ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();  </span><br><span class="line">        FileInputStream fis = new FileInputStream(file);  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            int i = fis.read(arrayOfByte);  </span><br><span class="line">            if (i != -1) &#123;  </span><br><span class="line">                localByteArrayOutputStream.write(arrayOfByte, 0, i);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                return localByteArrayOutputStream.toByteArray();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到程序比较简单和我们之前描述的一样，核心部分就在文件拼接部分和修改三个头信息的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//依次将解壳DEX，加密后的源APK，加密后的源APK大小，拼接出新的Dex</span><br><span class="line">byte[] newdex = new byte[totalLen];  </span><br><span class="line">System.arraycopy(unShellDexArray, 0, newdex, 0, unShellDexLen);</span><br><span class="line">System.arraycopy(enSrcApkArray, 0, newdex, unShellDexLen, enSrcApkLen);</span><br><span class="line">System.arraycopy(intToByte(enSrcApkLen), 0, newdex, totalLen-4, 4);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//修改DEX file size文件头  </span><br><span class="line">fixFileSizeHeader(newdex);  </span><br><span class="line">//修改DEX SHA1 文件头  </span><br><span class="line">fixSHA1Header(newdex);  </span><br><span class="line">//修改DEX CheckSum文件头  </span><br><span class="line">fixCheckSumHeader(newdex);</span><br></pre></td></tr></table></figure>
<p>我们再来看下第三个项目：<br>加壳程序，这个程序主要负责将在JAVA项目中加密的源Apk获取及解密，以及动态加载源Apk。项目结构<br><img src="http://img.blog.csdn.net/20170618225019607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>我们看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line">package com.jju.yuxin.reforceapk;</span><br><span class="line"></span><br><span class="line">import android.app.Application;</span><br><span class="line">import android.app.Instrumentation;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.pm.ApplicationInfo;</span><br><span class="line">import android.content.pm.PackageManager;</span><br><span class="line">import android.content.res.AssetManager;</span><br><span class="line">import android.content.res.Resources;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.util.ArrayMap;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.zip.ZipEntry;</span><br><span class="line">import java.util.zip.ZipInputStream;</span><br><span class="line"></span><br><span class="line">import dalvik.system.DexClassLoader;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * =============================================================================</span><br><span class="line"> * Copyright (c) 2017 yuxin All rights reserved.</span><br><span class="line"> * Packname com.jju.yuxin.reforceapk</span><br><span class="line"> * Created by yuxin.</span><br><span class="line"> * Created time 2017/6/18 0018 下午 5:03.</span><br><span class="line"> * Version   1.0;</span><br><span class="line"> * Describe :</span><br><span class="line"> * History:</span><br><span class="line"> * ==============================================================================</span><br><span class="line"> */</span><br><span class="line">public class ProxyApplication extends Application&#123;</span><br><span class="line"></span><br><span class="line">    private static final String appkey = &quot;APPLICATION_CLASS_NAME&quot;;</span><br><span class="line">    private  static final String TAG=ProxyApplication.class.getSimpleName();</span><br><span class="line">    private String srcApkFilePath;</span><br><span class="line">    private String odexPath;</span><br><span class="line">    private String libPath;</span><br><span class="line">    //以下是加载资源</span><br><span class="line">    protected AssetManager mAssetManager;</span><br><span class="line">    protected Resources mResources;</span><br><span class="line">    protected Resources.Theme mTheme;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        super.attachBaseContext(base);</span><br><span class="line">        Log.d(TAG,&quot;----------onCreate&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            File odex = this.getDir(&quot;payload_odex&quot;, MODE_PRIVATE);</span><br><span class="line">            File libs = this.getDir(&quot;payload_lib&quot;, MODE_PRIVATE);</span><br><span class="line">            //用于存放源apk释放出来的dex</span><br><span class="line">            odexPath = odex.getAbsolutePath();</span><br><span class="line">            //用于存放源Apk用到的so文件</span><br><span class="line">            libPath = libs.getAbsolutePath();</span><br><span class="line">            //用于存放解密后的apk</span><br><span class="line">            srcApkFilePath = odex.getAbsolutePath() + &quot;/payload.apk&quot;;</span><br><span class="line"></span><br><span class="line">            File srcApkFile= new File(srcApkFilePath);</span><br><span class="line">            Log.i(&quot;demo&quot;, &quot;apk size:&quot;+srcApkFile.length());</span><br><span class="line"></span><br><span class="line">            //第一次加载</span><br><span class="line">            if (!srcApkFile.exists())</span><br><span class="line">            &#123;</span><br><span class="line">                Log.i(&quot;demo&quot;, &quot;isFirstLoading&quot;);</span><br><span class="line">                srcApkFile.createNewFile();</span><br><span class="line">                //拿到dex文件</span><br><span class="line">                byte[] dexdata = this.readDexFileFromApk();</span><br><span class="line">                //取出源APK解密后放置在/payload.apk，及其so文件放置在payload_lib/下</span><br><span class="line">                this.splitPayLoadFromDex(dexdata);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 配置动态加载环境</span><br><span class="line">            //反射获取主线程对象，并从中获取所有已加载的package信息，并中找到当前的LoadApk对象的弱引用</span><br><span class="line">            Object currentActivityThread = RefInvoke.invokeStaticMethod(</span><br><span class="line">                    &quot;android.app.ActivityThread&quot;, &quot;currentActivityThread&quot;,</span><br><span class="line">                    new Class[] &#123;&#125;, new Object[] &#123;&#125;);</span><br><span class="line">            String packageName = this.getPackageName();</span><br><span class="line">            ArrayMap mPackages = (ArrayMap) RefInvoke.getFieldOjbect(</span><br><span class="line">                    &quot;android.app.ActivityThread&quot;, currentActivityThread,</span><br><span class="line">                    &quot;mPackages&quot;);</span><br><span class="line">            WeakReference wr = (WeakReference) mPackages.get(packageName);</span><br><span class="line"></span><br><span class="line">            //创建一个新的DexClassLoader用于加载源Apk，</span><br><span class="line">            // 传入apk路径，dex释放路径，so路径，及父节点的DexClassLoader使其遵循双亲委托模型</span><br><span class="line">            DexClassLoader dLoader = new DexClassLoader(srcApkFilePath, odexPath,</span><br><span class="line">                    libPath, (ClassLoader) RefInvoke.getFieldOjbect(</span><br><span class="line">                    &quot;android.app.LoadedApk&quot;, wr.get(), &quot;mClassLoader&quot;));</span><br><span class="line"></span><br><span class="line">            //getClassLoader()等同于 (ClassLoader) RefInvoke.getFieldOjbect()</span><br><span class="line">            //但是为了替换掉父节点我们需要通过反射来获取并修改其值</span><br><span class="line">            Log.i(TAG,&quot;父classloader:&quot;+(ClassLoader) RefInvoke.getFieldOjbect(</span><br><span class="line">                    &quot;android.app.LoadedApk&quot;, wr.get(), &quot;mClassLoader&quot;));</span><br><span class="line">            //将父节点DexClassLoader替换</span><br><span class="line">            RefInvoke.setFieldOjbect(&quot;android.app.LoadedApk&quot;, &quot;mClassLoader&quot;,</span><br><span class="line">                    wr.get(), dLoader);</span><br><span class="line"></span><br><span class="line">            Log.i(TAG,&quot;子classloader:&quot;+dLoader);</span><br><span class="line"></span><br><span class="line">            try&#123;</span><br><span class="line">                //尝试加载源Apk的MainActivity</span><br><span class="line">                Object actObj = dLoader.loadClass(&quot;com.jju.yuxin.sourceproject.MainActivity&quot;);</span><br><span class="line"></span><br><span class="line">                Log.i(TAG, &quot;SrcApk_MainActivity:&quot;+actObj);</span><br><span class="line">            &#125;catch(Exception e)&#123;</span><br><span class="line">                Log.i(TAG, &quot;LoadSrcActivityErr:&quot;+Log.getStackTraceString(e));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.i(TAG, &quot;error:&quot;+Log.getStackTraceString(e));</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line"></span><br><span class="line">            //加载源apk资源</span><br><span class="line">            //loadResources(srcApkFilePath);</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, &quot;--------onCreate&quot;);</span><br><span class="line">            //获取配置在清单文件的源Apk的Application路劲</span><br><span class="line">            String appClassName = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                ApplicationInfo ai = this.getPackageManager()</span><br><span class="line">                        .getApplicationInfo(this.getPackageName(),</span><br><span class="line">                                PackageManager.GET_META_DATA);</span><br><span class="line">                Bundle bundle = ai.metaData;</span><br><span class="line">                if (bundle != null &amp;&amp; bundle.containsKey(&quot;APPLICATION_CLASS_NAME&quot;)) &#123;</span><br><span class="line">                    appClassName = bundle.getString(&quot;APPLICATION_CLASS_NAME&quot;);//className 是配置在xml文件中的。</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.i(TAG, &quot;have no application class name&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                Log.i(TAG, &quot;error:&quot;+Log.getStackTraceString(e));</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //获取当前壳Apk的ApplicationInfo</span><br><span class="line">            Object currentActivityThread = RefInvoke.invokeStaticMethod(</span><br><span class="line">                    &quot;android.app.ActivityThread&quot;, &quot;currentActivityThread&quot;,</span><br><span class="line">                    new Class[] &#123;&#125;, new Object[] &#123;&#125;);</span><br><span class="line">            Object mBoundApplication = RefInvoke.getFieldOjbect(</span><br><span class="line">                    &quot;android.app.ActivityThread&quot;, currentActivityThread,</span><br><span class="line">                    &quot;mBoundApplication&quot;);</span><br><span class="line">            Object loadedApkInfo = RefInvoke.getFieldOjbect(</span><br><span class="line">                    &quot;android.app.ActivityThread$AppBindData&quot;,</span><br><span class="line">                    mBoundApplication, &quot;info&quot;);</span><br><span class="line">            //将LoadedApk中的ApplicationInfo设置为null</span><br><span class="line">            RefInvoke.setFieldOjbect(&quot;android.app.LoadedApk&quot;, &quot;mApplication&quot;,</span><br><span class="line">                    loadedApkInfo, null);</span><br><span class="line"></span><br><span class="line">            //获取currentActivityThread中注册的Application</span><br><span class="line">            Object oldApplication = RefInvoke.getFieldOjbect(</span><br><span class="line">                    &quot;android.app.ActivityThread&quot;, currentActivityThread,</span><br><span class="line">                    &quot;mInitialApplication&quot;);</span><br><span class="line"></span><br><span class="line">            //获取ActivityThread中所有已注册的Application，并将当前壳Apk的Application从中移除</span><br><span class="line">            ArrayList&lt;Application&gt; mAllApplications = (ArrayList&lt;Application&gt;) RefInvoke</span><br><span class="line">                    .getFieldOjbect(&quot;android.app.ActivityThread&quot;,</span><br><span class="line">                            currentActivityThread, &quot;mAllApplications&quot;);</span><br><span class="line">            mAllApplications.remove(oldApplication);</span><br><span class="line"></span><br><span class="line">            ApplicationInfo appinfo_In_LoadedApk = (ApplicationInfo) RefInvoke</span><br><span class="line">                    .getFieldOjbect(&quot;android.app.LoadedApk&quot;, loadedApkInfo,</span><br><span class="line">                            &quot;mApplicationInfo&quot;);</span><br><span class="line"></span><br><span class="line">            ApplicationInfo appinfo_In_AppBindData = (ApplicationInfo) RefInvoke</span><br><span class="line">                    .getFieldOjbect(&quot;android.app.ActivityThread$AppBindData&quot;,</span><br><span class="line">                            mBoundApplication, &quot;appInfo&quot;);</span><br><span class="line">            //替换原来的Application</span><br><span class="line">            appinfo_In_LoadedApk.className = appClassName;</span><br><span class="line">            appinfo_In_AppBindData.className = appClassName;</span><br><span class="line"></span><br><span class="line">            //注册Application</span><br><span class="line">            Application app = (Application) RefInvoke.invokeMethod(</span><br><span class="line">                    &quot;android.app.LoadedApk&quot;, &quot;makeApplication&quot;, loadedApkInfo,</span><br><span class="line">                    new Class[] &#123; boolean.class, Instrumentation.class &#125;,</span><br><span class="line">                    new Object[] &#123; false, null &#125;);</span><br><span class="line"></span><br><span class="line">            //替换ActivityThread中的Application</span><br><span class="line">            RefInvoke.setFieldOjbect(&quot;android.app.ActivityThread&quot;,</span><br><span class="line">                    &quot;mInitialApplication&quot;, currentActivityThread, app);</span><br><span class="line"></span><br><span class="line">            ArrayMap mProviderMap = (ArrayMap) RefInvoke.getFieldOjbect(</span><br><span class="line">                    &quot;android.app.ActivityThread&quot;, currentActivityThread,</span><br><span class="line">                    &quot;mProviderMap&quot;);</span><br><span class="line"></span><br><span class="line">            Iterator it = mProviderMap.values().iterator();</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                Object providerClientRecord = it.next();</span><br><span class="line">                Object localProvider = RefInvoke.getFieldOjbect(</span><br><span class="line">                        &quot;android.app.ActivityThread$ProviderClientRecord&quot;,</span><br><span class="line">                        providerClientRecord, &quot;mLocalProvider&quot;);</span><br><span class="line">                RefInvoke.setFieldOjbect(&quot;android.content.ContentProvider&quot;,</span><br><span class="line">                        &quot;mContext&quot;, localProvider, app);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, &quot;Srcapp:&quot;+app);</span><br><span class="line"></span><br><span class="line">            app.onCreate();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void splitPayLoadFromDex(byte[] shelldexdata) throws IOException &#123;</span><br><span class="line">        int sdlen = shelldexdata.length;</span><br><span class="line">        //取被加壳apk的长度</span><br><span class="line">        byte[] dexlen = new byte[4];</span><br><span class="line">        System.arraycopy(shelldexdata, sdlen - 4, dexlen, 0, 4);</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(dexlen);</span><br><span class="line">        DataInputStream in = new DataInputStream(bais);</span><br><span class="line">        int readInt = in.readInt();</span><br><span class="line">        Log.d(TAG,&quot;Integer.toHexString(readInt):&quot;+Integer.toHexString(readInt));</span><br><span class="line"></span><br><span class="line">        //取出apk</span><br><span class="line">        byte[] ensrcapk = new byte[readInt];</span><br><span class="line">        System.arraycopy(shelldexdata, sdlen - 4 - readInt, ensrcapk, 0, readInt);</span><br><span class="line"></span><br><span class="line">        //对源程序Apk进行解密</span><br><span class="line">        byte[]  srcapk = decrypt(ensrcapk);</span><br><span class="line"></span><br><span class="line">        //写入源apk文件</span><br><span class="line">        File file = new File(srcApkFilePath);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileOutputStream localFileOutputStream = new FileOutputStream(file);</span><br><span class="line">            localFileOutputStream.write(srcapk);</span><br><span class="line">            localFileOutputStream.close();</span><br><span class="line">        &#125; catch (IOException localIOException) &#123;</span><br><span class="line">            throw new RuntimeException(localIOException);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //分析源apk文件</span><br><span class="line">        ZipInputStream localZipInputStream = new ZipInputStream(</span><br><span class="line">                new BufferedInputStream(new FileInputStream(file)));</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            ZipEntry localZipEntry = localZipInputStream.getNextEntry();</span><br><span class="line">            if (localZipEntry == null) &#123;</span><br><span class="line">                localZipInputStream.close();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //依次取出被加壳apk用到的so文件，放到 libPath中（data/data/包名/payload_lib)</span><br><span class="line">            String name = localZipEntry.getName();</span><br><span class="line">            if (name.startsWith(&quot;lib/&quot;) &amp;&amp; name.endsWith(&quot;.so&quot;)) &#123;</span><br><span class="line">                File storeFile = new File(libPath + &quot;/&quot;</span><br><span class="line">                        + name.substring(name.lastIndexOf(&apos;/&apos;)));</span><br><span class="line">                storeFile.createNewFile();</span><br><span class="line">                FileOutputStream fos = new FileOutputStream(storeFile);</span><br><span class="line">                byte[] arrayOfByte = new byte[1024];</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    int i = localZipInputStream.read(arrayOfByte);</span><br><span class="line">                    if (i == -1)</span><br><span class="line">                        break;</span><br><span class="line">                    fos.write(arrayOfByte, 0, i);</span><br><span class="line">                &#125;</span><br><span class="line">                fos.flush();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">            localZipInputStream.closeEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        localZipInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 拿到自己apk文件中的dex文件</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    private byte[] readDexFileFromApk() throws IOException &#123;</span><br><span class="line">        ByteArrayOutputStream dexByteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        ZipInputStream localZipInputStream = new ZipInputStream(</span><br><span class="line">                new BufferedInputStream(new FileInputStream(</span><br><span class="line">                        this.getApplicationInfo().sourceDir)));</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            ZipEntry localZipEntry = localZipInputStream.getNextEntry();</span><br><span class="line">            if (localZipEntry == null) &#123;</span><br><span class="line">                localZipInputStream.close();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //拿到dex文件</span><br><span class="line">            if (localZipEntry.getName().equals(&quot;classes.dex&quot;)) &#123;</span><br><span class="line">                byte[] arrayOfByte = new byte[1024];</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    int i = localZipInputStream.read(arrayOfByte);</span><br><span class="line">                    if (i == -1)</span><br><span class="line">                        break;</span><br><span class="line">                    dexByteArrayOutputStream.write(arrayOfByte, 0, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            localZipInputStream.closeEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        localZipInputStream.close();</span><br><span class="line">        return dexByteArrayOutputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // //直接返回数据，读者可以添加自己解密方法</span><br><span class="line">    private byte[] decrypt(byte[] srcdata) &#123;</span><br><span class="line">        for(int i=0;i&lt;srcdata.length;i++)&#123;</span><br><span class="line">            srcdata[i] = (byte)(0xFF ^ srcdata[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return srcdata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected void loadResources(String srcApkPath) &#123;</span><br><span class="line">        //创建一个AssetManager放置源apk的资源</span><br><span class="line">        try &#123;</span><br><span class="line">            AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">            Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);</span><br><span class="line">            addAssetPath.invoke(assetManager, srcApkPath);</span><br><span class="line">            mAssetManager = assetManager;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.i(TAG, &quot;inject:loadResource error:&quot;+Log.getStackTraceString(e));</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Resources superRes = super.getResources();</span><br><span class="line">        superRes.getDisplayMetrics();</span><br><span class="line">        superRes.getConfiguration();</span><br><span class="line">        mResources = new Resources(mAssetManager, superRes.getDisplayMetrics(),superRes.getConfiguration());</span><br><span class="line">        mTheme = mResources.newTheme();</span><br><span class="line">        mTheme.setTo(super.getTheme());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public AssetManager getAssets() &#123;</span><br><span class="line">        return mAssetManager == null ? super.getAssets() : mAssetManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Resources getResources() &#123;</span><br><span class="line">        return mResources == null ? super.getResources() : mResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Resources.Theme getTheme() &#123;</span><br><span class="line">        return mTheme == null ? super.getTheme() : mTheme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个文件比较长我们来依次分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//第一次加载</span><br><span class="line">if (!srcApkFile.exists())</span><br><span class="line">&#123;</span><br><span class="line">    Log.i(&quot;demo&quot;, &quot;isFirstLoading&quot;);</span><br><span class="line">    srcApkFile.createNewFile();</span><br><span class="line">    //拿到dex文件</span><br><span class="line">    byte[] dexdata = this.readDexFileFromApk();</span><br><span class="line">    //取出源APK解密后放置在/payload.apk，及其so文件放置在payload_lib/下</span><br><span class="line">    this.splitPayLoadFromDex(dexdata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过判断用于存放解密后的源Apk文件是否存在来判断是否是第一次加载。第一次加载时通过readDexFileFromApk（）来获取当前Apk的Dex文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 拿到自己apk文件中的dex文件</span><br><span class="line"> * @return</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">private byte[] readDexFileFromApk() throws IOException &#123;</span><br><span class="line">    ByteArrayOutputStream dexByteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">    ZipInputStream localZipInputStream = new ZipInputStream(</span><br><span class="line">            new BufferedInputStream(new FileInputStream(</span><br><span class="line">                    this.getApplicationInfo().sourceDir)));</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        ZipEntry localZipEntry = localZipInputStream.getNextEntry();</span><br><span class="line">        if (localZipEntry == null) &#123;</span><br><span class="line">            localZipInputStream.close();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        //拿到dex文件</span><br><span class="line">        if (localZipEntry.getName().equals(&quot;classes.dex&quot;)) &#123;</span><br><span class="line">            byte[] arrayOfByte = new byte[1024];</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                int i = localZipInputStream.read(arrayOfByte);</span><br><span class="line">                if (i == -1)</span><br><span class="line">                    break;</span><br><span class="line">                dexByteArrayOutputStream.write(arrayOfByte, 0, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        localZipInputStream.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">    localZipInputStream.close();</span><br><span class="line">    return dexByteArrayOutputStream.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过this.splitPayLoadFromDex();将当前Dex分解，从中获取源Apk并将其解密，以及源Apk的so库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private void splitPayLoadFromDex(byte[] shelldexdata) throws IOException &#123;</span><br><span class="line">       int sdlen = shelldexdata.length;</span><br><span class="line">       //取被加壳apk的长度</span><br><span class="line">       byte[] dexlen = new byte[4];</span><br><span class="line">       System.arraycopy(shelldexdata, sdlen - 4, dexlen, 0, 4);</span><br><span class="line">       ByteArrayInputStream bais = new ByteArrayInputStream(dexlen);</span><br><span class="line">       DataInputStream in = new DataInputStream(bais);</span><br><span class="line">       int readInt = in.readInt();</span><br><span class="line">       Log.d(TAG,&quot;Integer.toHexString(readInt):&quot;+Integer.toHexString(readInt));</span><br><span class="line"></span><br><span class="line">       //取出apk</span><br><span class="line">       byte[] ensrcapk = new byte[readInt];</span><br><span class="line">       System.arraycopy(shelldexdata, sdlen - 4 - readInt, ensrcapk, 0, readInt);</span><br><span class="line"></span><br><span class="line">       //对源程序Apk进行解密</span><br><span class="line">       byte[]  srcapk = decrypt(ensrcapk);</span><br><span class="line"></span><br><span class="line">       //写入源apk文件</span><br><span class="line">       File file = new File(srcApkFilePath);</span><br><span class="line">       try &#123;</span><br><span class="line">           FileOutputStream localFileOutputStream = new FileOutputStream(file);</span><br><span class="line">           localFileOutputStream.write(srcapk);</span><br><span class="line">           localFileOutputStream.close();</span><br><span class="line">       &#125; catch (IOException localIOException) &#123;</span><br><span class="line">           throw new RuntimeException(localIOException);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //分析源apk文件</span><br><span class="line">       ZipInputStream localZipInputStream = new ZipInputStream(</span><br><span class="line">               new BufferedInputStream(new FileInputStream(file)));</span><br><span class="line"></span><br><span class="line">       while (true) &#123;</span><br><span class="line">           ZipEntry localZipEntry = localZipInputStream.getNextEntry();</span><br><span class="line">           if (localZipEntry == null) &#123;</span><br><span class="line">               localZipInputStream.close();</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           //依次取出被加壳apk用到的so文件，放到 libPath中（data/data/包名/payload_lib)</span><br><span class="line">           String name = localZipEntry.getName();</span><br><span class="line">           if (name.startsWith(&quot;lib/&quot;) &amp;&amp; name.endsWith(&quot;.so&quot;)) &#123;</span><br><span class="line">               File storeFile = new File(libPath + &quot;/&quot;</span><br><span class="line">                       + name.substring(name.lastIndexOf(&apos;/&apos;)));</span><br><span class="line">               storeFile.createNewFile();</span><br><span class="line">               FileOutputStream fos = new FileOutputStream(storeFile);</span><br><span class="line">               byte[] arrayOfByte = new byte[1024];</span><br><span class="line">               while (true) &#123;</span><br><span class="line">                   int i = localZipInputStream.read(arrayOfByte);</span><br><span class="line">                   if (i == -1)</span><br><span class="line">                       break;</span><br><span class="line">                   fos.write(arrayOfByte, 0, i);</span><br><span class="line">               &#125;</span><br><span class="line">               fos.flush();</span><br><span class="line">               fos.close();</span><br><span class="line">           &#125;</span><br><span class="line">           localZipInputStream.closeEntry();</span><br><span class="line">       &#125;</span><br><span class="line">       localZipInputStream.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后通过动态加载机制将加壳程序的ClassLoader替换成他的子ClassLoader这样确保既能加载自己的Class又能加载源Apk的Class<br>核心代码，如果这段代码不是很懂，你可能需要去了解Java反射，Android中Classloader的双亲委托模型，以及动态加载机制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DexClassLoader dLoader = new DexClassLoader(srcApkFilePath, odexPath,</span><br><span class="line">        libPath, (ClassLoader) RefInvoke.getFieldOjbect(</span><br><span class="line">        &quot;android.app.LoadedApk&quot;, wr.get(), &quot;mClassLoader&quot;));</span><br></pre></td></tr></table></figure></p>
<p>然后在Application的onCreate（）中替换LoadApk以及ActivityThread中的Application，希望更清楚的明白这点需要了解下Android中Activity以及Application的启动流程，其中在加壳程序的清单文件中我们配置了源Apk的相关信息以便能找到他们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:allowBackup=&quot;true&quot;</span><br><span class="line">    android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;</span><br><span class="line">    android:supportsRtl=&quot;true&quot;</span><br><span class="line">    android:name=&quot;.ProxyApplication&quot;</span><br><span class="line">    android:theme=&quot;@style/AppTheme&quot;&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=&quot;APPLICATION_CLASS_NAME&quot;</span><br><span class="line">        android:value=&quot;com.jju.yuxin.sourceproject.SourceApplication&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;activity android:name=&quot;com.jju.yuxin.sourceproject.MainActivity&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line">    &lt;activity android:name=&quot;com.jju.yuxin.sourceproject.SubActivity&quot;&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
<p>实现操作流程：<br>先将源Apk的项目生成Apk，放置到JAVA项目中<br><img src="http://img.blog.csdn.net/20170618231438854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>将加壳程序也生成Apk，通过直接将apk后缀名改成zip的方式获取到classes.dex,（最好复制一份，这个后面还要用）。将classes.dex改名成shelldex.dex放置到JAVA项目中<br><img src="http://img.blog.csdn.net/20170618231912901?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>运行JAVA项目，将生成新的Dex文件classes.dex，将新生成的classes.dex替换加壳Apk的classes.dex(通过解压软件直接拖放进去替换即可)<br><img src="http://img.blog.csdn.net/20170618232244294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>最后cd到apktool的目录下，使用apktool中的jarsigner对应用重新签名即可，重新签名指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -keystore 签名文件路径 -storepass 密码 -keypass 密码 -sigfile CERT -digestalg SHA1 -sigalg MD5withRSA -signedjar 签名后生成Apk路径 需要签名Apk路径 签名文件别名</span><br><span class="line">//例如：jarsigner -verbose -keystore yuxin.jks -storepass 123456 -keypass 123456 -sigfile CERT -digestalg SHA1 -sigalg MD5withRSA -signedjar ReforceApk_des.apk reforce.apk yuxin</span><br></pre></td></tr></table></figure>
<p>这三个项目的Github地址（<a href="https://github.com/huyuxin95/DexShellProject" target="_blank" rel="noopener">项目地址</a>）</p>
<p>常见错误：</p>
<ul>
<li><p>ClassNotFoundException：</p>
<p> 这个错误主要注意：Class路径拼写有没错，加密Apk能否正确的转为源Apk，还有就是ClassLoader有没用错</p>
</li>
<li><p>Class ref in pre-verified class resolved to unexpected<br>implementation：<br>这是类被重复加载的错误，需要检查报错的类是否被别的ClassLoder已经加载过了，我的Activity在继承android.support.v7.app.AppCompatActivity时候报了这个错误，改成Activity就好了，原因还没去找。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/30/csharp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/30/csharp/" itemprop="url">C#中的委托和事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-30T20:33:39+08:00">
                2017-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文地址:<a href="http://www.cnblogs.com/JimmyZhang/archive/2007/09/23/903360.html" target="_blank" rel="noopener">C# 中的委托和事件</a></p>
</blockquote>
<p>###引言</p>
<blockquote>
<p>委托 和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。</p>
</blockquote>
<p>###将方法作为方法的参数</p>
<p>我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void GreetPeople(string name) &#123;</span><br><span class="line">    // 做某些额外的事情，比如初始化之类，此处略</span><br><span class="line">    EnglishGreeting(name);</span><br><span class="line">&#125;</span><br><span class="line">public void EnglishGreeting(string name) &#123;</span><br><span class="line">    Console.WriteLine(&quot;Morning, &quot; + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。</p>
<p>现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void ChineseGreeting(string name)&#123;</span><br><span class="line">    Console.WriteLine(&quot;早上好, &quot; + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public enum Language&#123;</span><br><span class="line">    English, Chinese</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void GreetPeople(string name, Language lang)&#123;</span><br><span class="line">    //做某些额外的事情，比如初始化之类，此处略</span><br><span class="line">    swith(lang)&#123;</span><br><span class="line">        case Language.English:</span><br><span class="line">           EnglishGreeting(name);</span><br><span class="line">           break;</span><br><span class="line">       case Language.Chinese:</span><br><span class="line">           ChineseGreeting(name);</span><br><span class="line">           break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。</p>
<p>在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void GreetPeople(string name, Language lang)</span><br></pre></td></tr></table></figure>
<p>我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。</p>
<p>如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MakeGreeting(name);</span><br></pre></td></tr></table></figure>
<p>好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void GreetPeople(string name, *** MakeGreeting)&#123;</span><br><span class="line">    MakeGreeting(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到 *** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：这个代表着方法的MakeGreeting参数应该是什么类型的？</p>
<p>NOTE：这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是 EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。</p>
<p>聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void EnglishGreeting(string name)</span><br><span class="line">public void ChineseGreeting(string name)</span><br></pre></td></tr></table></figure>
<p>如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。MakeGreeting的 参数类型定义 应该能够确定 MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。</p>
<p>于是，委托出现了：它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。</p>
<p>NOTE：如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的值的种类，也就是name参数的类型。</p>
<p>本例中委托的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate void GreetingDelegate(string name);</span><br></pre></td></tr></table></figure>
<p>可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？</p>
<p>现在，让我们再次改动GreetPeople()方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void GreetPeople(string name, GreetingDelegate MakeGreeting)&#123;</span><br><span class="line">    MakeGreeting(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace Delegate &#123;</span><br><span class="line">     //定义委托，它定义了可以代表的方法的类型</span><br><span class="line">     public delegate void GreetingDelegate(string name);</span><br><span class="line">        class Program &#123;</span><br><span class="line"></span><br><span class="line">           private static void EnglishGreeting(string name) &#123;</span><br><span class="line">               Console.WriteLine(&quot;Morning, &quot; + name);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           private static void ChineseGreeting(string name) &#123;</span><br><span class="line">               Console.WriteLine(&quot;早上好, &quot; + name);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //注意此方法，它接受一个GreetingDelegate类型的方法作为参数</span><br><span class="line">           private static void GreetPeople(string name, GreetingDelegate MakeGreeting) &#123;</span><br><span class="line">               MakeGreeting(name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           static void Main(string[] args) &#123;</span><br><span class="line">               GreetPeople(&quot;Jimmy Zhang&quot;, EnglishGreeting);</span><br><span class="line">               GreetPeople(&quot;张子阳&quot;, ChineseGreeting);</span><br><span class="line">               Console.ReadKey();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure>
<p>我们现在对委托做一个总结：</p>
<p>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。</p>
<p>将方法绑定到委托</p>
<p>看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在GreetPeople()方法中给 name参数赋值，我可以像这样使用变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    string name1, name2;</span><br><span class="line">    name1 = &quot;Jimmy Zhang&quot;;</span><br><span class="line">    name2 = &quot;张子阳&quot;; </span><br><span class="line"></span><br><span class="line">     GreetPeople(name1, EnglishGreeting);</span><br><span class="line">     GreetPeople(name2, ChineseGreeting);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而既然委托GreetingDelegate 和 类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    GreetingDelegate delegate1, delegate2;</span><br><span class="line">    delegate1 = EnglishGreeting;</span><br><span class="line">    delegate2 = ChineseGreeting;</span><br><span class="line"></span><br><span class="line">    GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);</span><br><span class="line">        GreetPeople(&quot;张子阳&quot;, delegate2);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于string的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting; // 先给委托类型的变量赋值</span><br><span class="line">    delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</span><br><span class="line"></span><br><span class="line">     // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span><br><span class="line">    GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);  </span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure>
<p>实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting; // 先给委托类型的变量赋值</span><br><span class="line">    delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</span><br><span class="line"></span><br><span class="line">    // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span><br><span class="line">    delegate1 (&quot;Jimmy Zhang&quot;);   </span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NOTE：这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。</p>
</blockquote>
<p>注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。</p>
<p>我们也可以使用下面的代码来这样简化这一过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);</span><br><span class="line">delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</span><br></pre></td></tr></table></figure>
<p>看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“+=”的编译错误，或许可以用这样的方法来避免：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GreetingDelegate delegate1 = new GreetingDelegate();</span><br><span class="line">delegate1 += EnglishGreeting;   // 这次用的是 “+=”，绑定语法。</span><br><span class="line">delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</span><br></pre></td></tr></table></figure>
<p>但实际上，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。</p>
<p>既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);</span><br><span class="line">    delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</span><br><span class="line"></span><br><span class="line">    // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span><br><span class="line">    GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);  </span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    delegate1 -= EnglishGreeting; //取消对EnglishGreeting方法的绑定</span><br><span class="line">    // 将仅调用 ChineseGreeting </span><br><span class="line">    GreetPeople(&quot;张子阳&quot;, delegate1); </span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure>
<p>让我们再次对委托作个总结：</p>
<p>使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。</p>
<p>事件的由来</p>
<p>我们继续思考上面的程序：上面的三个方法都定义在Programe类中，这样做是为了理解的方便，实际应用中，通常都是 GreetPeople 在一个类中，ChineseGreeting和 EnglishGreeting 在另外的类中。现在你已经对委托有了初步了解，是时候对上面的例子做个改进了。假设我们将GreetingPeople()放在一个叫GreetingManager的类中，那么新程序应该是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">namespace Delegate &#123;</span><br><span class="line">    //定义委托，它定义了可以代表的方法的类型</span><br><span class="line">    public delegate void GreetingDelegate(string name);</span><br><span class="line">    </span><br><span class="line">    //新建的GreetingManager类</span><br><span class="line">    public class GreetingManager&#123;</span><br><span class="line">       public void GreetPeople(string name, GreetingDelegate MakeGreeting) &#123;</span><br><span class="line">           MakeGreeting(name);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Program &#123;</span><br><span class="line">       private static void EnglishGreeting(string name) &#123;</span><br><span class="line">           Console.WriteLine(&quot;Morning, &quot; + name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       private static void ChineseGreeting(string name) &#123;</span><br><span class="line">           Console.WriteLine(&quot;早上好, &quot; + name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       static void Main(string[] args) &#123;</span><br><span class="line">           // ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，如果要实现前面演示的输出效果，Main方法我想应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    GreetingManager gm = new  GreetingManager();</span><br><span class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;, EnglishGreeting);</span><br><span class="line">    gm.GreetPeople(&quot;张子阳&quot;, ChineseGreeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们运行这段代码，嗯，没有任何问题。程序一如预料地那样输出了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line"></span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure>
<p>现在，假设我们需要使用上一节学到的知识，将多个方法绑定到同一个委托变量，该如何做呢？让我们再次改写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    GreetingManager gm = new  GreetingManager();</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting;</span><br><span class="line">    delegate1 += ChineseGreeting;</span><br><span class="line"></span><br><span class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure>
<p>到了这里，我们不禁想到：面向对象设计，讲究的是对象的封装，既然可以声明委托类型的变量(在上例中是delegate1)，我们何不将这个变量封装到 GreetManager类中？在这个类的客户端中使用不是更方便么？于是，我们改写GreetManager类，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GreetingManager&#123;</span><br><span class="line">    //在GreetingManager类的内部声明delegate1变量</span><br><span class="line">    public GreetingDelegate delegate1;  </span><br><span class="line"></span><br><span class="line">    public void GreetPeople(string name, GreetingDelegate MakeGreeting) &#123;</span><br><span class="line">       MakeGreeting(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以这样使用这个委托变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    GreetingManager gm = new  GreetingManager();</span><br><span class="line">    gm.delegate1 = EnglishGreeting;</span><br><span class="line">    gm.delegate1 += ChineseGreeting;</span><br><span class="line"></span><br><span class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;, gm.delegate1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure>
<p>尽管这样做没有任何问题，但我们发现这条语句很奇怪。在调用gm.GreetPeople方法的时候，再次传递了gm的delegate1字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gm.GreetPeople(&quot;Jimmy Zhang&quot;, gm.delegate1);</span><br></pre></td></tr></table></figure>
<p>既然如此，我们何不修改 GreetingManager 类成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class GreetingManager&#123;</span><br><span class="line">    //在GreetingManager类的内部声明delegate1变量</span><br><span class="line">    public GreetingDelegate delegate1;  </span><br><span class="line"></span><br><span class="line">    public void GreetPeople(string name) &#123;</span><br><span class="line">        if(delegate1!=null)&#123;     //如果有方法注册委托变量</span><br><span class="line">          delegate1(name);      //通过委托调用方法</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端，调用看上去更简洁一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    GreetingManager gm = new  GreetingManager();</span><br><span class="line">    gm.delegate1 = EnglishGreeting;</span><br><span class="line">    gm.delegate1 += ChineseGreeting;</span><br><span class="line"></span><br><span class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;);      //注意，这次不需要再传递 delegate1变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure>
<p>尽管这样达到了我们要的效果，但是还是存在着问题：</p>
<p>在这里，delegate1和我们平时用的string类型的变量没有什么分别，而我们知道，并不是所有的字段都应该声明成public，合适的做法是应该public的时候public，应该private的时候private。</p>
<p>我们先看看如果把 delegate1 声明为 private会怎样？结果就是：这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为private了，客户端对它根本就不可见，那它还有什么用？</p>
<p>再看看把delegate1 声明为 public 会怎样？结果就是：在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。</p>
<p>最后，第一个方法注册用“=”，是赋值语法，因为要进行实例化，第二个方法注册则用的是“+=”。但是，不管是赋值还是注册，都是将方法绑定到委托上，除了调用时先后顺序不同，再没有任何的分别，这样不是让人觉得很别扭么？</p>
<p>现在我们想想，如果delegate1不是一个委托类型，而是一个string类型，你会怎么做？答案是使用属性对字段进行封装。</p>
<p>于是，Event出场了，它封装了委托类型的变量，使得：在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。</p>
<p>我们改写GreetingManager类，它变成了这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GreetingManager&#123;</span><br><span class="line">    //这一次我们在这里声明一个事件</span><br><span class="line">    public event GreetingDelegate MakeGreet;</span><br><span class="line"></span><br><span class="line">    public void GreetPeople(string name) &#123;</span><br><span class="line">        MakeGreet(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易注意到：MakeGreet 事件的声明与之前委托变量delegate1的声明唯一的区别是多了一个event关键字。看到这里，在结合上面的讲解，你应该明白到：事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。</p>
<p>为了证明上面的推论，如果我们像下面这样改写Main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    GreetingManager gm = new  GreetingManager();</span><br><span class="line">    gm.MakeGreet = EnglishGreeting;         // 编译错误1</span><br><span class="line">    gm.MakeGreet += ChineseGreeting;</span><br><span class="line"></span><br><span class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会得到编译错误：事件“Delegate.GreetingManager.MakeGreet”只能出现在 += 或 -= 的左边(从类型“Delegate.GreetingManager”中使用时除外)。</p>
<p>###事件和委托的编译代码</p>
<p>这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 event的声明语句做一探究，看看为什么会发生这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public event GreetingDelegate MakeGreet;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170330203047008?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看到，实际上尽管我们在GreetingManager里将 MakeGreet 声明为public，但是，实际上MakeGreet会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在GreetingManager类的外面以赋值的方式访问，从而验证了我们上面所做的推论。</p>
<p>我们再进一步看下MakeGreet所产生的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private GreetingDelegate MakeGreet; //对事件的声明 实际是 声明一个私有的委托变量</span><br><span class="line"> </span><br><span class="line">[MethodImpl(MethodImplOptions.Synchronized)]</span><br><span class="line">public void add_MakeGreet(GreetingDelegate value)&#123;</span><br><span class="line">    this.MakeGreet = (GreetingDelegate) Delegate.Combine(this.MakeGreet, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[MethodImpl(MethodImplOptions.Synchronized)]</span><br><span class="line">public void remove_MakeGreet(GreetingDelegate value)&#123;</span><br><span class="line">    this.MakeGreet = (GreetingDelegate) Delegate.Remove(this.MakeGreet, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在已经很明确了：MakeGreet事件确实是一个GreetingDelegate类型的委托，只不过不管是不是声明为public，它总是被声明为private。另外，它还有两个方法，分别是add_MakeGreet和remove_MakeGreet，这两个方法分别用于注册委托类型的方法和取消注册。实际上也就是： “+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet。而这两个方法的访问限制取决于声明事件时的访问限制符。</p>
<p>在add_MakeGreet()方法内部，实际上调用了System.Delegate的Combine()静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate void GreetingDelegate(string name);</span><br></pre></td></tr></table></figure>
<p>当编译器遇到这段代码的时候，会生成下面这样一个完整的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public sealed class GreetingDelegate:System.MulticastDelegate&#123;</span><br><span class="line">    public GreetingDelegate(object @object, IntPtr method);</span><br><span class="line">    public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object @object);</span><br><span class="line">    public virtual void EndInvoke(IAsyncResult result);</span><br><span class="line">    public virtual void Invoke(string name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170330203111525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>关于这个类的更深入内容，可以参阅《CLR Via C#》等相关书籍，这里就不再讨论了。</p>
<p>委托、事件与Observer设计模式</p>
<p>###范例说明</p>
<p>上面的例子已不足以再进行下面的讲解了，我们来看一个新的范例，因为之前已经介绍了很多的内容，所以本节的进度会稍微快一些：</p>
<p>假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。</p>
<p>现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">namespace Delegate &#123;</span><br><span class="line">    class Heater &#123;</span><br><span class="line">    private int temperature; // 水温</span><br><span class="line">    // 烧水</span><br><span class="line">    public void BoilWater() &#123;</span><br><span class="line">        for (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">           temperature = i;</span><br><span class="line"></span><br><span class="line">           if (temperature &gt; 95) &#123;</span><br><span class="line">               MakeAlert(temperature);</span><br><span class="line">               ShowMsg(temperature);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 发出语音警报</span><br><span class="line">    private void MakeAlert(int param) &#123;</span><br><span class="line">       Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot; , param);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 显示水温</span><br><span class="line">    private void ShowMsg(int param) &#123;</span><br><span class="line">       Console.WriteLine(&quot;Display：水快开了，当前温度：&#123;0&#125;度。&quot; , param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main() &#123;</span><br><span class="line">       Heater ht = new Heater();</span><br><span class="line">       ht.BoilWater();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###Observer设计模式简介</p>
<p>上面的例子显然能完成我们之前描述的工作，但是却并不够好。现在假设热水器由三部分组成：热水器、警报器、显示器，它们来自于不同厂商并进行了组装。那么，应该是热水器仅仅负责烧水，它不能发出警报也不能显示水温；在水烧开时由警报器发出警报、显示器显示提示和水温。</p>
<p>这时候，上面的例子就应该变成这个样子：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 热水器</span><br><span class="line">public class Heater &#123; </span><br><span class="line">    private int temperature;</span><br><span class="line">        </span><br><span class="line">    // 烧水</span><br><span class="line">    private void BoilWater() &#123;</span><br><span class="line">       for (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">           temperature = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 警报器</span><br><span class="line">public class Alarm&#123;</span><br><span class="line">    private void MakeAlert(int param) &#123;</span><br><span class="line">       Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot; , param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 显示器</span><br><span class="line">public class Display&#123;</span><br><span class="line">    private void ShowMsg(int param) &#123;</span><br><span class="line">       Console.WriteLine(&quot;Display：水已烧开，当前温度：&#123;0&#125;度。&quot; , param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就出现了一个问题：如何在水烧开的时候通知报警器和显示器？在继续进行之前，我们先了解一下Observer设计模式，Observer设计模式中主要包括如下两类对象：</p>
<p>Subject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。<br>Observer：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。<br>在本例中，事情发生的顺序应该是这样的：</p>
<p>警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。<br>热水器知道后保留对警报器和显示器的引用。<br>热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的MakeAlert()方法、显示器的ShowMsg()方法。<br>类似这样的例子是很多的，GOF对它进行了抽象，称为Observer设计模式：Observer设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。Observer模式是一种松耦合的设计模式。</p>
<p>###实现范例的Observer设计模式</p>
<p>我们之前已经对委托和事件介绍很多了，现在写代码应该很容易了，现在在这里直接给出代码，并在注释中加以说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace Delegate &#123;</span><br><span class="line">    // 热水器</span><br><span class="line">    public class Heater &#123;</span><br><span class="line">       private int temperature;</span><br><span class="line">       public delegate void BoilHandler(int param);   //声明委托</span><br><span class="line">       public event BoilHandler BoilEvent;        //声明事件</span><br><span class="line"></span><br><span class="line">       // 烧水</span><br><span class="line">       public void BoilWater() &#123;</span><br><span class="line">           for (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">              temperature = i;</span><br><span class="line"></span><br><span class="line">              if (temperature &gt; 95) &#123;</span><br><span class="line">                  if (BoilEvent != null) &#123; //如果有对象注册</span><br><span class="line">                      BoilEvent(temperature);  //调用所有注册对象的方法</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 警报器</span><br><span class="line">    public class Alarm &#123;</span><br><span class="line">       public void MakeAlert(int param) &#123;</span><br><span class="line">           Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot;, param);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 显示器</span><br><span class="line">    public class Display &#123;</span><br><span class="line">       public static void ShowMsg(int param) &#123; //静态方法</span><br><span class="line">           Console.WriteLine(&quot;Display：水快烧开了，当前温度：&#123;0&#125;度。&quot;, param);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Program &#123;</span><br><span class="line">       static void Main() &#123;</span><br><span class="line">           Heater heater = new Heater();</span><br><span class="line">           Alarm alarm = new Alarm();</span><br><span class="line"></span><br><span class="line">           heater.BoilEvent += alarm.MakeAlert;    //注册方法</span><br><span class="line">           heater.BoilEvent += (new Alarm()).MakeAlert;   //给匿名对象注册方法</span><br><span class="line">           heater.BoilEvent += Display.ShowMsg;       //注册静态方法</span><br><span class="line"></span><br><span class="line">           heater.BoilWater();   //烧水，会自动调用注册过对象的方法</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alarm：嘀嘀嘀，水已经 96 度了：</span><br><span class="line">Alarm：嘀嘀嘀，水已经 96 度了：</span><br><span class="line">Display：水快烧开了，当前温度：96度。</span><br><span class="line">// 省略...</span><br></pre></td></tr></table></figure>
<p>###.Net Framework中的委托与事件</p>
<p>尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？</p>
<p>在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范：</p>
<ul>
<li>委托类型的名称都应该以EventHandler结束。</li>
<li>委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个<br>EventArgs类型(或继承自EventArgs)。</li>
<li>事件的命名为 委托去掉 EventHandler之后剩余的部分。</li>
<li>继承自EventArgs的类型应该以EventArgs结尾。</li>
</ul>
<p>再做一下说明：</p>
<p>委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。<br>EventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。<br>上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性。比如说，如果我们不光想获得热水器的温度，还想在Observer端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。</p>
<p>现在我们改写之前的范例，让它符合 .Net Framework 的规范：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace Delegate &#123;</span><br><span class="line">    // 热水器</span><br><span class="line">    public class Heater &#123;</span><br><span class="line">       private int temperature;</span><br><span class="line">       public string type = &quot;RealFire 001&quot;;       // 添加型号作为演示</span><br><span class="line">       public string area = &quot;China Xian&quot;;         // 添加产地作为演示</span><br><span class="line">       //声明委托</span><br><span class="line">       public delegate void BoiledEventHandler(Object sender, BoiledEventArgs e);</span><br><span class="line">       public event BoiledEventHandler Boiled; //声明事件</span><br><span class="line"></span><br><span class="line">       // 定义BoiledEventArgs类，传递给Observer所感兴趣的信息</span><br><span class="line">       public class BoiledEventArgs : EventArgs &#123;</span><br><span class="line">           public readonly int temperature;</span><br><span class="line">           public BoiledEventArgs(int temperature) &#123;</span><br><span class="line">              this.temperature = temperature;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视</span><br><span class="line">       protected virtual void OnBoiled(BoiledEventArgs e) &#123;</span><br><span class="line">           if (Boiled != null) &#123; // 如果有对象注册</span><br><span class="line">              Boiled(this, e);  // 调用所有注册对象的方法</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       // 烧水。</span><br><span class="line">       public void BoilWater() &#123;</span><br><span class="line">           for (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">              temperature = i;</span><br><span class="line">              if (temperature &gt; 95) &#123;</span><br><span class="line">                  //建立BoiledEventArgs 对象。</span><br><span class="line">                  BoiledEventArgs e = new BoiledEventArgs(temperature);</span><br><span class="line">                  OnBoiled(e);  // 调用 OnBolied方法</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 警报器</span><br><span class="line">    public class Alarm &#123;</span><br><span class="line">       public void MakeAlert(Object sender, Heater.BoiledEventArgs e) &#123;</span><br><span class="line">           Heater heater = (Heater)sender;     //这里是不是很熟悉呢？</span><br><span class="line">           //访问 sender 中的公共字段</span><br><span class="line">           Console.WriteLine(&quot;Alarm：&#123;0&#125; - &#123;1&#125;: &quot;, heater.area, heater.type);</span><br><span class="line">           Console.WriteLine(&quot;Alarm: 嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot;, e.temperature);</span><br><span class="line">           Console.WriteLine();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 显示器</span><br><span class="line">    public class Display &#123;</span><br><span class="line">       public static void ShowMsg(Object sender, Heater.BoiledEventArgs e) &#123;   //静态方法</span><br><span class="line">           Heater heater = (Heater)sender;</span><br><span class="line">           Console.WriteLine(&quot;Display：&#123;0&#125; - &#123;1&#125;: &quot;, heater.area, heater.type);</span><br><span class="line">           Console.WriteLine(&quot;Display：水快烧开了，当前温度：&#123;0&#125;度。&quot;, e.temperature);</span><br><span class="line">           Console.WriteLine();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Program &#123;</span><br><span class="line">       static void Main() &#123;</span><br><span class="line">           Heater heater = new Heater();</span><br><span class="line">           Alarm alarm = new Alarm();</span><br><span class="line"></span><br><span class="line">           heater.Boiled += alarm.MakeAlert;   //注册方法</span><br><span class="line">           heater.Boiled += (new Alarm()).MakeAlert;      //给匿名对象注册方法</span><br><span class="line">           heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert);    //也可以这么注册</span><br><span class="line">           heater.Boiled += Display.ShowMsg;       //注册静态方法</span><br><span class="line"></span><br><span class="line">           heater.BoilWater();   //烧水，会自动调用注册过对象的方法</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">Alarm：China Xian - RealFire 001:</span><br><span class="line">Alarm: 嘀嘀嘀，水已经 96 度了：</span><br><span class="line">Alarm：China Xian - RealFire 001:</span><br><span class="line">Alarm: 嘀嘀嘀，水已经 96 度了：</span><br><span class="line">Alarm：China Xian - RealFire 001:</span><br><span class="line">Alarm: 嘀嘀嘀，水已经 96 度了：</span><br><span class="line">Display：China Xian - RealFire 001:</span><br><span class="line">Display：水快烧开了，当前温度：96度。</span><br><span class="line">// 省略 ...</span><br></pre></td></tr></table></figure>
<p>###总结</p>
<p>在本文中我首先通过一个GreetingPeople的小程序向大家介绍了委托的概念、委托用来做什么，随后又引出了事件，接着对委托与事件所产生的中间代码做了粗略的讲述。</p>
<p>在第二个稍微复杂点的热水器的范例中，我向大家简要介绍了 Observer设计模式，并通过实现这个范例完成了该模式，随后讲述了.Net Framework中委托、事件的实现方式。</p>
<p>希望这篇文章能给你带来帮助。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/viewpage-fragment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/20/viewpage-fragment/" itemprop="url">Android中ViewPager+Fragment取消(禁止)预加载延迟加载(懒加载)问题解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-20T11:49:41+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在Android中我们经常会用到ViewPager+Fragment组合。然而，有一个很让人头疼的问题就是，我们去加载数据的时候由于ViewPager的内部机制所限制，所以它会默认至少预加载一个。这让人很郁闷，所以，我就想到要封装一个Fragment来解决这个问题。<br>这里还解决一个问题就是在<em><a href="http://blog.csdn.net/linglongxin24/article/details/53115253" target="_blank" rel="noopener">Android酷炫欢迎页播放视频,仿蚂蜂窝自由行和慕课网</a></em><br>这里感谢有一位网友提出了bug,就是在播放视频的时候如果滑动到第二页和第三页，第一页的视频还在播放，这是个让人很头疼的问题，在这里也完美解决。</p>
</blockquote>
<h2 id="问题初探"><a href="#问题初探" class="headerlink" title="问题初探:"></a>问题初探:</h2><p> 在Fragment可见时请求数据。此方案仍预加载了前后的页面，但是没有请求数据，只有进入到当前Framgent时才请求数据。那么我们在这里去加载数据会怎么样呢？ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FragmentSample extends Fragment&#123;</span><br><span class="line">    ...  </span><br><span class="line">    @Override</span><br><span class="line">    public void setUserVisibleHint(boolean isVisibleToUser) &#123;</span><br><span class="line">        super.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        if (isVisibleToUser) &#123;</span><br><span class="line">            requestData(); // 在此请求数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170120150845423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这又是为什么呢？<br>因为ViewPager会加载好多Fragment，为了节省内容等会在Fragment不可见的某个时候调用onDestroyView()将用户界面销毁掉但是Fragment的实例还在，所以可能第一次加载没有问题，<br>但是再次回到第一个Fragment再去加载的时候就会出现UI对用户可见但是视图还没有初始化。</p>
<h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一:"></a>解决方案一:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">package cn.bluemobi.dylan.viewpagerfragmentlazyload;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.support.annotation.Nullable;</span><br><span class="line">import android.support.v4.app.Fragment;</span><br><span class="line">import android.text.TextUtils;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Fragment预加载问题的解决方案：</span><br><span class="line"> * 1.可以懒加载的Fragment</span><br><span class="line"> * 2.切换到其他页面时停止加载数据（可选）</span><br><span class="line"> * Created by yuandl on 2016-11-17.</span><br><span class="line"> * blog ：http://blog.csdn.net/linglongxin24/article/details/53205878</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public abstract class LazyLoadFragment extends Fragment &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 视图是否已经初初始化</span><br><span class="line">     */</span><br><span class="line">    protected boolean isInit = false;</span><br><span class="line">    protected boolean isLoad = false;</span><br><span class="line">    protected final String TAG = &quot;LazyLoadFragment&quot;;</span><br><span class="line">    private View view;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        view = inflater.inflate(setContentView(), container, false);</span><br><span class="line">        isInit = true;</span><br><span class="line">        /**初始化的时候去加载数据**/</span><br><span class="line">        isCanLoadData();</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 视图是否已经对用户可见，系统的方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void setUserVisibleHint(boolean isVisibleToUser) &#123;</span><br><span class="line">        super.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        isCanLoadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否可以加载数据</span><br><span class="line">     * 可以加载数据的条件：</span><br><span class="line">     * 1.视图已经初始化</span><br><span class="line">     * 2.视图对用户可见</span><br><span class="line">     */</span><br><span class="line">    private void isCanLoadData() &#123;</span><br><span class="line">        if (!isInit) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (getUserVisibleHint()) &#123;</span><br><span class="line">            lazyLoad();</span><br><span class="line">            isLoad = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (isLoad) &#123;</span><br><span class="line">                stopLoad();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 视图销毁的时候讲Fragment是否初始化的状态变为false</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroyView() &#123;</span><br><span class="line">        super.onDestroyView();</span><br><span class="line">        isInit = false;</span><br><span class="line">        isLoad = false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void showToast(String message) &#123;</span><br><span class="line">        if (!TextUtils.isEmpty(message)) &#123;</span><br><span class="line">            Toast.makeText(getContext(), message, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置Fragment要显示的布局</span><br><span class="line">     *</span><br><span class="line">     * @return 布局的layoutId</span><br><span class="line">     */</span><br><span class="line">    protected abstract int setContentView();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取设置的布局</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected View getContentView() &#123;</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 找出对应的控件</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected &lt;T extends View&gt; T findViewById(int id) &#123;</span><br><span class="line"></span><br><span class="line">        return (T) getContentView().findViewById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当视图初始化并且对用户可见的时候去真正的加载数据</span><br><span class="line">     */</span><br><span class="line">    protected abstract void lazyLoad();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当视图已经对用户不可见并且加载过数据，如果需要在切换到其他页面时停止加载数据，可以覆写此方法</span><br><span class="line">     */</span><br><span class="line">    protected void stopLoad() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法:</p>
<p>LazyLoadFragment是一个抽象类，可以作为BaseFragment,继承它。</p>
<ul>
<li>用setContentView()方法去加载要显示的布局</li>
<li>lazyLoad()方法去加载数据</li>
<li>stopLoad()方法可选，当视图已经对用户不可见并且加载过数据，如果需要在切换到其他页面时停止加载数据，可以覆写此方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package cn.bluemobi.dylan.viewpagerfragmentlazyload;</span><br><span class="line"></span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Created by yuandl on 2016-11-17.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public class Fragment1 extends LazyLoadFragment &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public int setContentView() &#123;</span><br><span class="line">     return R.layout.fm_layout1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void lazyLoad() &#123;</span><br><span class="line">     String message = &quot;Fragment1&quot; + (isInit ? &quot;已经初始并已经显示给用户可以加载数据&quot; : &quot;没有初始化不能加载数据&quot;)+&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;;</span><br><span class="line">     showToast(message);</span><br><span class="line">     Log.d(TAG, message);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void stopLoad() &#123;</span><br><span class="line">     Log.d(TAG, &quot;Fragment1&quot; + &quot;已经对用户不可见，可以停止加载数据&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二:"></a>解决方案二:</h2><p>直接继承ViewPager，结合PagerAdapter实现懒加载。该方案是我用到的最完善的方法，完全的懒加载，每次只会建立一个Fragment对象。</p>
<p>开源库：<a href="https://github.com/lianghanzhen/LazyViewPager" target="_blank" rel="noopener">https://github.com/lianghanzhen/LazyViewPager</a></p>
<p>这个库就4个类，作者通过继承ViewPager（保证其普适性）、自定义ViewPagerAdapter和 LazyFragmentPagerAdapter以及设置懒加载的标记接口，很好的实现了懒加载。感谢作者。</p>
<p><b>最后提醒一下：</b><br>填充LazyViewPager的Fragment一定要实现接口LazyFragmentPagerAdapter.Laziable。</p>
<blockquote>
<p>参考<br><a href="http://www.cnblogs.com/wangfeng520/p/6108189.html" target="_blank" rel="noopener">Android中ViewPager+Fragment取消(禁止)预加载延迟加载(懒加载)问题解决方案</a><br><a href="http://blog.csdn.net/baidu_26654149/article/details/50992748" target="_blank" rel="noopener">实现ViewPager懒加载的三种方法</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/07/as-jcenter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/07/as-jcenter/" itemprop="url">Android Studio发布library到jCenter(问题集合)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-07T11:49:23+08:00">
                2016-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>烦心简单的事情折腾一天了,现在将碰到的问题集中写下,方便以后查询<br>试过两种方法</p>
<ul>
<li><p>gradle-bintray-plugin插件<br>有点麻烦,不过对于几种jar生成的过程都有详细的配置,基本没有编码格式困惑 ,推荐篇文章:<a href="http://blog.csdn.net/ls1110924/article/details/46470059" target="_blank" rel="noopener">在AndroidStudio中，使用Gradle打包aar到JCenter仓库！完整版教程!填补各种坑</a></p>
</li>
<li><p>bintray-release插件<br>还不错快速完成工具,编码设置比较麻烦,特别是代码和注释都出现中文的情况, ,推荐篇郭神的文章:<a href="http://blog.csdn.net/lmj623565791/article/details/51148825" target="_blank" rel="noopener"> Android 快速发布开源项目到jcenter</a></p>
</li>
</ul>
<h2 id="下面说下碰到的问题"><a href="#下面说下碰到的问题" class="headerlink" title="下面说下碰到的问题"></a>下面说下碰到的问题</h2><hr>
<p>1.Error:Execution failed for task ‘:viewpagerutilslib-v1:bintrayUpload’.&gt; Could not create package&gt; ‘xxxxx/maven/xxxxxxxxx’: HTTP/1.1 401 Unauthorized</p>
<p>401 这个错误很明显是认证错误,可能是你的用户名或者API key错了</p>
<hr>
<p> 2.Error:Execution failed for task ‘:viewpagerutilslib-v1:bintrayUpload’.&gt; Could not create package&gt; ‘xxxxxx/maven/xxxxx’: HTTP/1.1 404 Not Found</p>
<p>这个404问题比较坑爹,卡在这里绝大部分时间首先你在上传library到bintray之前,你需要先在bintrary new一个仓库名称和type都应该是maven<br><img src="http://img.blog.csdn.net/20161207112635569?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>其次:新建maven项目后从网址能看到你的用户名，比如我的<a href="https://bintray.com/huyuxin95/maven" target="_blank" rel="noopener">https://bintray.com/huyuxin95/maven</a>,<br>与userOrg = ‘huyuxin95’对应，但是userOrg不一定与登录用户名-PbintrayUser=***一样！)<br><img src="http://img.blog.csdn.net/20161207113119542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGF5RGF5UGxheVBob25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p>3.androidstudio mavenAndroidJavadocs FAILED GBK编码不可映射</p>
<p>这是因为你的注释有中文,在项目的build.gradle中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> allprojects &#123;</span><br><span class="line">    tasks.withType(Javadoc) &#123;</span><br><span class="line">        options&#123;</span><br><span class="line">            encoding &quot;UTF-8&quot;</span><br><span class="line">            charSet &apos;UTF-8&apos;</span><br><span class="line">            links &quot;http://docs.oracle.com/javase/7/docs/api&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>4.批处理macOS与windows的区别<br>macos:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean build bintrayUpload </span><br><span class="line">-PbintrayUser=hyman </span><br><span class="line">-PbintrayKey=xxxxxxxxxxxxxxxxxxxxxx </span><br><span class="line">-PdryRun=false</span><br></pre></td></tr></table></figure>
<p>windows</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gradlew.bat clean build bintrayUpload </span><br><span class="line"> -PbintrayUser=huyuxin </span><br><span class="line"> -PbintrayKey=32d8bc328c5131d7c76f5205333f2df5d2744632</span><br><span class="line"> -PdryRun=false</span><br></pre></td></tr></table></figure>
<p>如果你的windows还没安装gradlew.bat,他会帮你先下载,大概70M,但是如果网络差你可以将提示的下载地址复制到浏览器或者迅雷用第三方下载工具下载,这样快点,手动下载完复制到<code>C:\Users\username\.gradle\wrapper\dists\gradle-指定版本-all\随机字符</code>的文件夹下重启AS,再运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gradlew.bat clean build bintrayUpload </span><br><span class="line"> -PbintrayUser=huyuxin </span><br><span class="line"> -PbintrayKey=32d8bc328c5131d7c76f5205333f2df5d2744632</span><br><span class="line"> -PdryRun=false</span><br></pre></td></tr></table></figure>
<p>他解压好压缩包就可以了</p>
<hr>
<p> 5.提示这样的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:app:lint&apos;.</span><br><span class="line">&gt; Lint found errors in the project; aborting build.</span><br><span class="line"></span><br><span class="line">Fix the issues identified by lint, or add the following to your build script to proceed with errors:</span><br><span class="line">...</span><br><span class="line">android &#123;</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在library的build.gradle的android下 添加即可<br>如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 23</span><br><span class="line">    buildToolsVersion &quot;23.0.2&quot;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 15</span><br><span class="line">        targetSdkVersion 23</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    lintOptions&#123;</span><br><span class="line">        abortOnError false</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/21/dep-inj/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/21/dep-inj/" itemprop="url">深度理解依赖注入（Dependence Injection）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-21T19:30:43+08:00">
                2016-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> &nbsp; &nbsp; 前面的话：提到依赖注入，大家都会想到老马(Michael Mattson)那篇经典的文章。其实，本文就是相当于对那篇文章的解读。所以，如果您对原文已经有了非常深刻的理解，完全不需要再看此文；但是，如果您和笔者一样，以前曾经看过，似乎看懂了，但似乎又没抓到什么要领，不妨看看笔者这个解读，也许对您理解原文有一定帮助。</p>
<h2 id="1-依赖在哪里"><a href="#1-依赖在哪里" class="headerlink" title="1.依赖在哪里"></a>1.依赖在哪里</h2><p>   &nbsp; &nbsp;  老马举了一个小例子，是开发一个电影列举器（MovieList），这个电影列举器需要使用一个电影查找器（MovieFinder）提供的服务，伪码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> /*服务的接口*/</span><br><span class="line"> public interface MovieFinder &#123;</span><br><span class="line">     ArrayList findAll();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> /*服务的消费者*/</span><br><span class="line"> class MovieLister</span><br><span class="line"> &#123;</span><br><span class="line">    public Movie[] moviesDirectedBy(String arg) &#123;</span><br><span class="line">        List allMovies = finder.findAll();</span><br><span class="line">        for (Iterator it = allMovies.iterator(); it.hasNext();) &#123;</span><br><span class="line">            Movie movie = (Movie) it.next();</span><br><span class="line">            if (!movie.getDirector().equals(arg)) it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*消费者内部包含一个将指向具体服务类型的实体对象*/</span><br><span class="line">    private MovieFinder finder;</span><br><span class="line">    /*消费者需要在某一个时刻去实例化具体的服务。这是我们要解耦的关键所在，</span><br><span class="line">     *因为这样的处理方式造成了服务消费者和服务提供者的强耦合关系（这种耦合是在编译期就确定下来的）。</span><br><span class="line">     **/</span><br><span class="line">    public MovieLister() &#123;</span><br><span class="line">        finder = new ColonDelimitedMovieFinder(&quot;movies1.txt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> &nbsp; &nbsp; 从上面代码的注释中可以看到，MovieLister和ColonDelimitedMovieFinder（这可以使任意一个实现了MovieFinder接口的类型）之间存在强耦合关系，如下图所示(图1)：<br><img src="http://img.blog.csdn.net/20161031191622526" alt="这里写图片描述"></p>
<p>这使得MovieList很难作为一个成熟的组件去发布，因为在不同的应用环境中（包括同一套软件系统被不同用户使用的时候），它所要依赖的电影查找器可能是千差万别的。所以，为了能实现真正的基于组件的开发，必须有一种机制能同时满足下面两个要求：</p>
<p> （1）解除MovieList对具体MoveFinder类型的强依赖（编译期依赖）。</p>
<p> （2）在运行的时候为MovieList提供正确的MovieFinder类型的实例。<br> &nbsp; &nbsp; 换句话说，就是在运行的时候才产生MovieList和MovieFinder之间的依赖关系（把这种依赖关系在一个合适的时候“注入”运行时），这恐怕就是Dependency Injection这个术语的由来。再换句话说，我们提到过解除强依赖，这并不是说MovieList和MovieFinder之间的依赖关系不存在了，事实上MovieList无论如何也需要某类MovieFinder提供的服务，我们只是把这种依赖的建立时间推后了，从编译器推迟到运行时了。<br>    &nbsp; &nbsp;依赖关系在OO程序中是广泛存在的，只要A类型中用到了B类型实例，A就依赖于B。前面笔者谈到的内容是把概念抽象到了服务使用者和服务提供者的角度，这也符合现在SOA的设计思路。从另一种抽象方式上来看，可以把MovieList看成我们要构建的主系统，而MovieFinder是系统中的plugin，主系统并不强依赖于任何一个插件，但一旦插件被加载，主系统就应该可以准确调用适当插件的功能。<br> &nbsp; &nbsp;   其实不管是面向服务的编程模式，还是基于插件的框架式编程，为了实现松耦合（服务调用者和提供者之间的or框架和插件之间的），都需要在必要的位置实现面向接口编程，在此基础之上，还应该有一种方便的机制实现具体类型之间的运行时绑定，这就是DI所要解决的问题。</p>
<h2 id="2-DI的实现方式"><a href="#2-DI的实现方式" class="headerlink" title="2.DI的实现方式"></a>2.DI的实现方式</h2><p>   &nbsp; &nbsp;  和上面的图1对应的是，如果我们的系统实现了依赖注入，组件间的依赖关系就变成了图2：<br><img src="http://img.blog.csdn.net/20161031191940030" alt="这里写图片描述"><br> &nbsp; &nbsp; 说白了，就是要提供一个容器，由容器来完成（1）具体ServiceProvider的创建（2）ServiceUser和ServiceProvider的运行时绑定。下面我们就依次来看一下三种典型的依赖注入方式的实现。特别要说明的是，要理解依赖注入的机制，关键是理解容器的实现方式。本文后面给出的容器参考实现，均为黄忠成老师的代码，笔者仅在其中加上了一些关键注释而已。</p>
<ul>
<li><p>2.1 Constructor Injection（构造器注入）</p>
<p>&nbsp; &nbsp;  我们可以看到，在整个依赖注入的数据结构中，涉及到的重要的类型就是ServiceUser, ServiceProvider和Assembler三者，而这里所说的构造器，指的是ServiceUser的构造器。也就是说，在构造ServiceUser实例的时候，才把真正的ServiceProvider传给他：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MovieLister</span><br><span class="line">&#123;</span><br><span class="line">   //其他内容，省略</span><br><span class="line"></span><br><span class="line">   public MovieLister(MovieFinder finder)</span><br><span class="line">   &#123;</span><br><span class="line">       this.finder = finder;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> &nbsp; &nbsp; 接下来我们看看Assembler应该如何构建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> private MutablePicoContainer configureContainer() &#123;</span><br><span class="line">     MutablePicoContainer pico = new DefaultPicoContainer();</span><br><span class="line">     </span><br><span class="line">     //下面就是把ServiceProvider和ServiceUser都放入容器的过程，以后就由容器来提供ServiceUser的已完成依赖注入实例，</span><br><span class="line">     //其中用到的实例参数和类型参数一般是从配置档中读取的，这里是个简单的写法。</span><br><span class="line">     //所有的依赖注入方法都会有类似的容器初始化过程，本文在后面的小节中就不再重复这一段代码了。</span><br><span class="line">     Parameter[] finderParams =  &#123;new ConstantParameter(&quot;movies1.txt&quot;)&#125;;</span><br><span class="line">     pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);</span><br><span class="line">     pico.registerComponentImplementation(MovieLister.class);</span><br><span class="line">    //至此，容器里面装入了两个类型，其中没给出构造参数的那一个（MovieLister）将依靠其在构造器中定义的传入参数类型，在容器中</span><br><span class="line">    //进行查找，找到一个类型匹配项即可进行构造初始化。</span><br><span class="line">    return pico;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> &nbsp; &nbsp;需要在强调一下的是，依赖并未消失，只是延后到了容器被构建的时刻。所以正如图2中您已经看到的，容器本身（更准确的说，是一个容器运行实例的构建过程）对ServiceUser和ServiceProvoder都是存在依赖关系的。所以，在这样的体系结构里，ServiceUser、ServiceProvider和容器都是稳定的，互相之间也没有任何依赖关系；所有的依赖关系、所有的变化都被封装进了容器实例的创建过程里，符合我们对服务应用的理解。而且，在实际开发中我们一般会采用配置文件来辅助容器实例的创建，将这种变化性排斥到编译期之外。<br>   即使还没给出后面的代码，你也一定猜得到，这个container类一定有一个GetInstance(Type t)这样的方法，这个方法会为我们返回一个已经注入完毕的MovieLister。 一个简单的应用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void testWithPico() </span><br><span class="line">&#123;</span><br><span class="line">    MutablePicoContainer pico = configureContainer();</span><br><span class="line">    MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);</span><br><span class="line">    Movie[] movies = lister.moviesDirectedBy(&quot;Sergio Leone&quot;);</span><br><span class="line">    assertEquals(&quot;Once Upon a Time in the West&quot;, movies[0].getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp; &nbsp;上面最关键的就是对pico.getComponentInstance的调用。Assembler会在这个时候调用MovieLister的构造器，构造器的参数就是当时通过<code>pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams)</code>设置进去的实际的ServiceProvider–ColonMovieFinder。下面请看这个容器的参考代码：<br>构造注入所需容器的伪码</p>
<ul>
<li><p>2.2 Setter Injection（设值注入）</p>
<p>&nbsp; &nbsp;这种注入方式和构造注入实在很类似，唯一的区别就是前者在构造函数的调用过程中进行注入，而它是通过给属性赋值来进行注入。无怪乎PicoContainer和Spring都是同时支持这两种注入方式。Spring对通过XML进行配置有比较好的支持，也使得Spring中更常使用设值注入的方式：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;MovieLister&quot; class=&quot;spring.MovieLister&quot;&gt;</span><br><span class="line">         &lt;property name=&quot;finder&quot;&gt;</span><br><span class="line">             &lt;ref local=&quot;MovieFinder&quot;/&gt;</span><br><span class="line">         &lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line">     &lt;bean id=&quot;MovieFinder&quot; class=&quot;spring.ColonMovieFinder&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;filename&quot;&gt;</span><br><span class="line">            &lt;value&gt;movies1.txt&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>&nbsp; &nbsp;下面也给出支持设值注入的容器参考实现，大家可以和构造器注入的容器对照起来看，里面的差别很小，主要的差别就在于，在获取对象实例（GetInstance）的时候，前者是通过反射得到待创建类型的构造器信息，然后根据构造器传入参数的类型在容器中进行查找，并构造出合适的实例；而后者是通过反射得到待创建类型的所有属性，然后根据属性的类型在容器中查找相应类型的实例。</p>
<p>设值注入的容器实现伪码</p>
<ul>
<li><p>2.3 Interface Injection (接口注入)</p>
<p>这是笔者认为最不够优雅的一种依赖注入方式。要实现接口注入，首先ServiceProvider要给出一个接口定义：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InjectFinder &#123;</span><br><span class="line">    void injectFinder(MovieFinder finder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，ServiceUser必须实现这个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MovieLister: InjectFinder</span><br><span class="line">&#123;</span><br><span class="line">   public void injectFinder(MovieFinder finder) &#123;</span><br><span class="line">      this.finder = finder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器所要做的，就是根据接口定义调用其中的inject方法完成注入过程，这里就不在赘述了，总的原理和上面两种依赖注入模式没有太多区别。</p>
<ul>
<li><p>2.4  除了DI，还有Service Locator</p>
<p>&nbsp; &nbsp; 上面提到的依赖注入只是消除ServiceUser和ServiceProvider之间的依赖关系的一种方法，还有另一种方法：服务定位器（Service Locator）。也就是说，由ServiceLocator来专门负责提供具体的ServiceProvider。当然，这样的话ServiceUser不仅要依赖于服务的接口，还依赖于ServiceContract。仍然是最早提到过的电影列举器的例子，如果使用Service Locator来解除依赖的话，整个依赖关系应当如下图所示(图3)：<br><img src="http://img.blog.csdn.net/20161031192643634" alt="这里写图片描述"><br>&nbsp; &nbsp;用起来也很简单，在一个适当的位置（比如在一组相关服务即将被调用之前）对ServiceLocator进行初始化，用到的时候就直接用ServiceLocator返回ServiceProvider实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//服务定位器的初始化</span><br><span class="line">ServiceLocator locator = new ServiceLocator();</span><br><span class="line">locator.loadService(&quot;MovieFinder&quot;, new ColonMovieFinder(&quot;movies1.txt&quot;));</span><br><span class="line">ServiceLocator.load(locator);</span><br><span class="line"></span><br><span class="line">//服务定义器的使用</span><br><span class="line">//其实这个使用方式体现了服务定位器和依赖注入模式的最大差别：ServiceUser需要显示的调用ServiceLocator，从而获取自己需要的服务对象；</span><br><span class="line">//而依赖注入则是隐式的由容器完成了这一切。</span><br><span class="line">MovieFinder finder = (MovieFinder) ServiceLocator.getService(&quot;MovieFinder&quot;);</span><br></pre></td></tr></table></figure>
<p>  &nbsp; &nbsp;正因为上面提到过的ServiceUser对ServiceLocator的依赖性，从提高模块的独立性（比如说，你可能把你构造的ServiceUser或者ServiceProvider给第三方使用）上来说，依赖注入可能更好一些，这恐怕也是为什么大多数的IOC框架都选用了DI的原因。ServiceLocator最大的优点可能在于实现起来非常简单，如果您开发的应用没有复杂到需要采用一个IOC框架的程度，也许您可以试着采用它。</p>
<h2 id="3-广义的服务"><a href="#3-广义的服务" class="headerlink" title="3.广义的服务"></a>3.广义的服务</h2><p>   文中很多地方提到服务使用者（ServiceUser）和服务提供者（ServiceProvider）的概念，这里的“服务”是一种非常广义的概念，在语法层面就是指最普通的依赖关系（类型A中有一个B类型的变量，则A依赖于B）。如果您把服务理解为WCF或者Web Service中的那种服务概念，您会发现上面所说的所有技术手段都是没有意义的。以WCF而论，其客户端和服务器端本就是依赖于Contract的松耦合关系，其实这也从另一个角度说明了SOA应用的优势所在。</p>
<blockquote>
<p>原文地址:<a href="http://www.cnblogs.com/xingyukun/archive/2007/10/20/931331.html" target="_blank" rel="noopener">深度理解依赖注入（Dependence Injection）</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/20/java-thread-runnable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/20/java-thread-runnable/" itemprop="url">Java多线程之Runnable VS Thread及其资源共享问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-20T21:07:16+08:00">
                2016-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于 Java 多线程编程中的 implements Runnable 与 extends Thread，部分同学可能会比较疑惑，它们之间究竟有啥区别和联系呢？他们是不是没啥区别随便选呢？实际中究竟该选择哪一个呢？</p>
<p>甚至网上不少博客文章以讹传讹得出不少谬论，那今天的走进科学栏目将带您一一揭开谜底。</p>
<h2 id="1、区别："><a href="#1、区别：" class="headerlink" title="1、区别："></a>1、区别：</h2><p>其实这块主要是围绕着接口和抽象类的区别以及一些设计原则而言的。</p>
<p><strong>1.1 Inheritance Option:</strong>   </p>
<blockquote>
<p>The limitation with “extends Thread” approach is that if you extend<br>Thread,  you can not extend anything else . Java does not support<br>multiple inheritance.  In reality , you do not need Thread class<br>behavior , because in order to use a thread you need to instantiate<br>one anyway. On the other hand, Implementing the Runnable interface<br>gives you the choice to extend any class you like , but still define<br>behavior that will be run by separate thread.</p>
</blockquote>
<p><strong>1.2 Reusability :</strong> </p>
<blockquote>
<p>In “implements Runnable” , we are creating a different Runnable class<br>for a specific behavior  job (if the work you want to be done is job).<br>It gives us the freedom to reuse the specific behavior job whenever<br>required. “extends Thread”  contains both thread and job specific<br>behavior code. Hence once thread completes execution , it can not be<br>restart again.</p>
</blockquote>
<p><strong>1.3 Object Oriented Design:</strong>  </p>
<blockquote>
<p>Implementing Runnable should be preferred . It does not specializing<br>or modifying the thread behavior . You are giving thread something to<br>run. We conclude that Composition is the better way. Composition means<br>two objects A and B satisfies has-a  relationship. “extends Thread”<br>is not a good Object Oriented practice.</p>
</blockquote>
<p><strong>1.4 Loosely-coupled :</strong> </p>
<blockquote>
<p>“implements Runnable” makes the code loosely-coupled and easier to<br>read . Because the code is split into two classes . Thread class for<br>the thread specific code and your Runnable implementation class for<br>your job that should be run by a thread code. “extends Thread”  makes<br>the code tightly coupled . Single class contains the thread code as<br>well as the job that needs to be done by the thread.</p>
</blockquote>
<p><strong>1.5 Functions overhead :</strong>  </p>
<blockquote>
<p>“extends Thread”  means inheriting all the functions of the Thread<br>class which we may do not need .  job can be done easily by Runnable<br>without the Thread class functions overhead.</p>
</blockquote>
<p>至此，个人是推荐优先选择  implements Runnable 。</p>
<h2 id="2、联系："><a href="#2、联系：" class="headerlink" title="2、联系："></a>2、联系：</h2><p>2.1 其实Thread类也是Runnable接口的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Thread extends Object implements Runnable</span><br></pre></td></tr></table></figure>
<p>2.2 启动线程都是 start() 方法</p>
<p>追踪Thread中的start()方法的定义，可以发现此方法中使用了private native void start0();其中native关键字表示可以调用操作系统的底层函数，这样的技术称为JNI技术（java Native Interface）。</p>
<p>但是在使用Runnable定义的子类中没有start()方法，只有Thread类中才有。此时观察Thread类，有一个构造方法：public Thread(Runnable targer)，此构造方法接受Runnable的子类实例，也就是说可以通过Thread类来启动Runnable实现的多线程。</p>
<p>但是可以看到它们子线程运行的位置不同，Thread运行在父类的run方法中，Runnable运行在实现Runnable接口的子类对象run方法中。</p>
<p>2.3 网传的一种缪论：用Runnable就可以实现资源共享，而 Thread 不可以</p>
<p>有同学的例子是这样的，<br>参考：<a href="http://developer.51cto.com/art/201203/321042.htm：" target="_blank" rel="noopener">http://developer.51cto.com/art/201203/321042.htm：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package tmp;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">	private int ticket = 10;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public MyThread(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for (int i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">			if (this.ticket &gt; 0) &#123;</span><br><span class="line">				System.out.println(this.name + &quot;卖票----&gt;&quot; + (this.ticket--));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread mt1 = new MyThread(&quot;一号窗口&quot;);</span><br><span class="line">		MyThread mt2 = new MyThread(&quot;二号窗口&quot;);</span><br><span class="line">		MyThread mt3 = new MyThread(&quot;三号窗口&quot;);</span><br><span class="line">		mt1.start();</span><br><span class="line">		mt2.start();</span><br><span class="line">		mt3.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 一号窗口卖票----&gt;10</span><br><span class="line">// 二号窗口卖票----&gt;10</span><br><span class="line">// 二号窗口卖票----&gt;9</span><br><span class="line">// 二号窗口卖票----&gt;8</span><br><span class="line">// 三号窗口卖票----&gt;10</span><br><span class="line">// 三号窗口卖票----&gt;9</span><br><span class="line">// 三号窗口卖票----&gt;8</span><br></pre></td></tr></table></figure>
<p>Runnable 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package tmp;</span><br><span class="line"></span><br><span class="line">class MyThread1 implements Runnable &#123;</span><br><span class="line">	private int ticket = 10;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for (int i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">			if (this.ticket &gt; 0) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + &quot;卖票----&gt;&quot; + (this.ticket--));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread1 mt = new MyThread1();</span><br><span class="line">		Thread t1 = new Thread(mt, &quot;一号窗口&quot;);</span><br><span class="line">		Thread t2 = new Thread(mt, &quot;二号窗口&quot;);</span><br><span class="line">		Thread t3 = new Thread(mt, &quot;三号窗口&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 二号窗口卖票----&gt;10</span><br><span class="line">// 三号窗口卖票----&gt;9</span><br><span class="line">// 三号窗口卖票----&gt;7</span><br><span class="line">// 一号窗口卖票----&gt;9</span><br><span class="line">// 三号窗口卖票----&gt;6</span><br><span class="line">// 二号窗口卖票----&gt;8</span><br><span class="line">// 三号窗口卖票----&gt;4</span><br><span class="line">// 一号窗口卖票----&gt;5</span><br><span class="line">// 三号窗口卖票----&gt;2</span><br><span class="line">// 二号窗口卖票----&gt;3</span><br><span class="line">// 一号窗口卖票----&gt;1</span><br></pre></td></tr></table></figure>
<p>由此差别，有同学就得出了一个结论：用Runnable就可以实现资源共享，而 Thread 不可以，这是他们的主要差别之一。。。</p>
<p>其实仔细看看代码就知道，这只是两种写法的区别，根本就不是 implements Runnable 与 extends Thread 的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyThread1 mt = new MyThread1();  </span><br><span class="line">Thread t1 = new Thread(mt,&quot;一号窗口&quot;);  </span><br><span class="line">Thread t2 = new Thread(mt,&quot;二号窗口&quot;);  </span><br><span class="line">Thread t3 = new Thread(mt,&quot;三号窗口&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = new Thread(new MyThread1(),&quot;一号窗口&quot;);  </span><br><span class="line">Thread t2 = new Thread(new MyThread1(),&quot;二号窗口&quot;);  </span><br><span class="line">Thread t3 = new Thread(new MyThread1(),&quot;三号窗口&quot;);</span><br></pre></td></tr></table></figure>
<p>其实，想要“资源共享”，Thread 也可以做到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static int ticket = 10;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 三号窗口卖票----&gt;10</span><br><span class="line">// 一号窗口卖票----&gt;9</span><br><span class="line">// 二号窗口卖票----&gt;9</span><br><span class="line">// 一号窗口卖票----&gt;7</span><br><span class="line">// 一号窗口卖票----&gt;5</span><br><span class="line">// 三号窗口卖票----&gt;8</span><br><span class="line">// 一号窗口卖票----&gt;4</span><br><span class="line">// 二号窗口卖票----&gt;6</span><br><span class="line">// 一号窗口卖票----&gt;2</span><br><span class="line">// 三号窗口卖票----&gt;3</span><br><span class="line">// 二号窗口卖票----&gt;1</span><br></pre></td></tr></table></figure>
<p>通过 static 就可以实现拥有共同的ticket=10，但问题也来了，你会发现一二号窗口都卖了第 9 张票。</p>
<h2 id="3、资源共享带来的问题：多线程的线程安全问题"><a href="#3、资源共享带来的问题：多线程的线程安全问题" class="headerlink" title="3、资源共享带来的问题：多线程的线程安全问题"></a>3、资源共享带来的问题：多线程的线程安全问题</h2><p>上面的例子以及结果证明了多线程场景下，需要留意线程安全的问题：</p>
<p>3.1 同步run()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void run()</span><br></pre></td></tr></table></figure>
<p>3.2 同步 class 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized (Test.class)</span><br></pre></td></tr></table></figure>
<p>3.3 同步某些静态对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final Object countLock = new Object();</span><br><span class="line">synchronized (countLock) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.4 最后给个完整的例子，模拟在线售票与查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package tmp;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo implements Runnable &#123;</span><br><span class="line">	String name;</span><br><span class="line">	//	static Integer tickets = 20;</span><br><span class="line">	private static AtomicInteger tickets = new AtomicInteger(20);</span><br><span class="line"></span><br><span class="line">	public Demo(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for (int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">			synchronized (tickets) &#123;</span><br><span class="line">				if (tickets.get() &gt; 0) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;我取票第&quot; + &quot;: &quot; + tickets.getAndDecrement() + &quot; 张票。&quot;);</span><br><span class="line">					//					tickets--;</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;==========现在查询还剩&quot; + &quot;: &quot; + tickets.get() + &quot; 张票。&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		Demo demo = new Demo(&quot;hello&quot;);</span><br><span class="line">		new Thread(demo).start();</span><br><span class="line">		new Thread(demo).start();</span><br><span class="line">		new Thread(demo).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这儿，本期走进科学也要跟大家说声再见了，其实聊着聊着感觉都快跑题了，多线程这块话题很多，很复杂，需要慢慢实践与积累，祝大家玩的愉快。</p>
<h2 id="4、附：白话并发"><a href="#4、附：白话并发" class="headerlink" title="4、附：白话并发"></a>4、附：白话并发</h2><p>办公室只有一个卫生间，一次只能容纳一个人方便，这个卫生间就是竞争条件（Race Condition）。当一个人进去后就在门口牌子上标识为“有人”，这个就相当于是线程的加锁，告诉其它同时间想要上厕所的人，这个资源已被我占位，其他人就需要等待，这叫wait。只有当前面的人出来后，并把牌子置为“无人”时，其它人才有机会使用。当只有一个蹲位时，一次只能进一个人，翻动一块牌子加一把锁，这个就叫互斥锁（Mutex）。如果卫生间里有多个蹲位，再简单地用一块牌子来标识就不行了，需要做一个电子公告牌，进去一个人电子公告牌就把可用数量减1，出来一个人数量加1，数量不为0时，有人来直接进去就行了不用等待，这个叫信号量（Semaphores）。如果出来的人是随机通知等待的某一个人，这叫notify，如果他是对着所有等待的人喊一嗓子，就是notifyAll。如果使用notify，有些倒霉的家伙可能永远也不会被通知到，这太不人性了，而如果使用nofityAll就意味着所有等待的人需要竞争资源，还是会在倒霉蛋永远轮不到。解决的办法一是按时间顺序先到先得，顺序进入，火车站的厕所经常会看到这种情况，总是有机会轮到自己，这叫公平锁（FairLock）。还有一种情况，就是大老板也在排队，一般情况下大老板时间宝贵，可以优先考虑让他先上，这叫线程优先级，一共有10个级别。优先级只能保证级别高的优先被调度到，但不能保证一定会被调度到。</p>
<p>两个好基友一起在蹲坑，只有一卷手纸，一个人去取时另一个就不能同时去取，这叫基于共享内存的线程间通信。两个人都是烟鬼，但只带了一个打火机，一个人用完之后递给另外一个人，</p>
<p>进程和线程的区别：一个办公区有多个卫生间，每个卫生间的资源是独立的，不会相互依赖，相当于是进程。每个卫生间有多个蹲位，每个蹲位相当于是一个线程，蹲位越多并发处理能力越强。但多个同一个卫生间的多个蹲位共用一个洗手台，如果蹲位过多，洗手台的资源会成为瓶颈。</p>
<p>原文：<a href="https://my.oschina.net/leejun2005/blog/483999" target="_blank" rel="noopener">https://my.oschina.net/leejun2005/blog/483999</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/13/view-scroll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/13/view-scroll/" itemprop="url">Android分析View的scrollBy()和scrollTo()的参数正负问题原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-13T16:56:03+08:00">
                2016-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Android设备平面直角坐标系</li>
</ul>
<p>在做分析之前，首先要建立起Android设备屏幕的平面直角坐标系概念。在Android手机中，屏幕的直角坐标轴概念简单来说：<br><img src="http://img.blog.csdn.net/20160913164651287" alt="这里写图片描述"></p>
<p>屏幕左上角为直角坐标系的原点(0,0)从原点出发向左为X轴负方向，向右为X轴正方向从原点出发向上为Y轴负方向，向下为Y轴正方向</p>
<p>上述概念可通过如下图总结：</p>
<p> 在Android中，我们通常说View在屏幕上的坐标，其实就是view的左上的坐标。调用View的invalidate()方法会促使View重绘。<br>View的scrollBy()和scrollTo()<br>在分析scrollBy()和scrollTo()之前，先上一段源码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Set the scrolled position of your view. This will cause a call to</span><br><span class="line"> * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class="line"> * invalidated.</span><br><span class="line"> * @param x the x position to scroll to</span><br><span class="line"> * @param y the y position to scroll to</span><br><span class="line"> */</span><br><span class="line">public void scrollTo(int x, int y) &#123;</span><br><span class="line">    if (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        int oldX = mScrollX;</span><br><span class="line">        int oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        if (!awakenScrollBars()) &#123;</span><br><span class="line">            invalidate(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Move the scrolled position of your view. This will cause a call to</span><br><span class="line"> * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class="line"> * invalidated.</span><br><span class="line"> * @param x the amount of pixels to scroll by horizontally</span><br><span class="line"> * @param y the amount of pixels to scroll by vertically</span><br><span class="line"> */</span><br><span class="line">public void scrollBy(int x, int y) &#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scrollBy()和scrollTo()的滚动不同点<br>scrollTo(x, y)：通过invalidate使view直接滚动到参数x和y所标定的坐标scrollBy(x, y)：通过相对于当前坐标的滚动。从上面代码中，很容以就能看出scrollBy()的方法体只有调用scrollTo()方法的一行代码，scrollBy()方法先对属性mScollX加上参数x和属性mScrollY加上参数y，然后将上述结果作为参数传入调用方法scrollTo()<br>scrollBy()和scrollTo()的参数正负影响滚动问题<br>scrollBy()和scrollTo()在参数为负的时候，向坐标轴正方向滚动；当参数为正的时候，向坐标轴负方向滚动。而作为我们的认知，应该是参数为负的时候，向坐标轴负方向滚动；当参数为正的时候，向坐标轴正方向滚动。</p>
<p>那为什么这两个方法传入参数和引起的滚动方向和我们平常的认知不同呢？</p>
<p>下面就让我们带着这个问题跟随源码分析。如果不想从它的执行过程一步步的去分析，可以直接看本文的最后一段源码。</p>
<ul>
<li>源码执行过程分析</li>
</ul>
<p>因为scrollBy(x, y)方法体只有一行，并且是调用scrollTo(x, y)，所以我们只要通过scrollTo(x, y)来进行分析就可以了。</p>
<p>在scrollTo(x, y)中，x和y分别被赋值给了mScrollX和mScrollY，最后调用了方法invalidate(true)。貌似到了这里就无路可走了，其实不然，我们知道invalidate这个方法会通知View进行重绘。</p>
<p>那么接下来，我们就可以跳过scrollTo(x, y)去分析View的draw()方法了。照例，在分析onDraw方法之前上一段源码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Manually render this view (and all of its children) to the given Canvas.</span><br><span class="line"> * The view must have already done a full layout before this function is</span><br><span class="line"> * called.  When implementing a view, implement</span><br><span class="line"> * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method.</span><br><span class="line"> * If you do need to override this method, call the superclass version.</span><br><span class="line"> *</span><br><span class="line"> * @param canvas The Canvas to which the View is rendered.</span><br><span class="line"> */</span><br><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">    if (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int privateFlags = mPrivateFlags;</span><br><span class="line">    final boolean dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">     * in the appropriate order:</span><br><span class="line">     *</span><br><span class="line">     *      1. Draw the background</span><br><span class="line">     *      2. If necessary, save the canvas&apos; layers to prepare for fading</span><br><span class="line">     *      3. Draw view&apos;s content</span><br><span class="line">     *      4. Draw children</span><br><span class="line">     *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">     *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // Step 1, draw the background, if needed</span><br><span class="line">    int saveCount;</span><br><span class="line"></span><br><span class="line">    if (!dirtyOpaque) &#123;</span><br><span class="line">        final Drawable background = mBGDrawable;</span><br><span class="line">        if (background != null) &#123;</span><br><span class="line">            final int scrollX = mScrollX;</span><br><span class="line">            final int scrollY = mScrollY;</span><br><span class="line"></span><br><span class="line">            if (mBackgroundSizeChanged) &#123;</span><br><span class="line">                background.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);</span><br><span class="line">                mBackgroundSizeChanged = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((scrollX | scrollY) == 0) &#123;</span><br><span class="line">                background.draw(canvas);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                canvas.translate(scrollX, scrollY);</span><br><span class="line">                background.draw(canvas);</span><br><span class="line">                canvas.translate(-scrollX, -scrollY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">    final int viewFlags = mViewFlags;</span><br><span class="line">    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class="line">    boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class="line">    if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        // Step 3, draw the content</span><br><span class="line">        if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 4, draw the children</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 6, draw decorations (scrollbars)</span><br><span class="line">        onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">        // we&apos;re done...</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Here we do the full fledged routine...</span><br><span class="line">     * (this is an uncommon case where speed matters less,</span><br><span class="line">     * this is why we repeat some of the tests that have been</span><br><span class="line">     * done above)</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    boolean drawTop = false;</span><br><span class="line">    boolean drawBottom = false;</span><br><span class="line">    boolean drawLeft = false;</span><br><span class="line">    boolean drawRight = false;</span><br><span class="line"></span><br><span class="line">    float topFadeStrength = 0.0f;</span><br><span class="line">    float bottomFadeStrength = 0.0f;</span><br><span class="line">    float leftFadeStrength = 0.0f;</span><br><span class="line">    float rightFadeStrength = 0.0f;</span><br><span class="line"></span><br><span class="line">    // Step 2, save the canvas&apos; layers</span><br><span class="line">    int paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">    final boolean offsetRequired = isPaddingOffsetRequired();</span><br><span class="line">    if (offsetRequired) &#123;</span><br><span class="line">        paddingLeft += getLeftPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int left = mScrollX + paddingLeft;</span><br><span class="line">    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">    int top = mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">    int bottom = top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">    if (offsetRequired) &#123;</span><br><span class="line">        right += getRightPaddingOffset();</span><br><span class="line">        bottom += getBottomPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ScrollabilityCache scrollabilityCache = mScrollCache;</span><br><span class="line">    final float fadeHeight = scrollabilityCache.fadingEdgeLength;        </span><br><span class="line">    int length = (int) fadeHeight;</span><br><span class="line"></span><br><span class="line">    // clip the fade length if top and bottom fades overlap</span><br><span class="line">    // overlapping fades produce odd-looking artifacts</span><br><span class="line">    if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">        length = (bottom - top) / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // also clip horizontal fades if necessary</span><br><span class="line">    if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">        length = (right - left) / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (verticalEdges) &#123;</span><br><span class="line">        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));</span><br><span class="line">        drawTop = topFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));</span><br><span class="line">        drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (horizontalEdges) &#123;</span><br><span class="line">        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));</span><br><span class="line">        drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));</span><br><span class="line">        drawRight = rightFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">    int solidColor = getSolidColor();</span><br><span class="line">    if (solidColor == 0) &#123;</span><br><span class="line">        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">        if (drawTop) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, right, top + length, null, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawBottom) &#123;</span><br><span class="line">            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawLeft) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, left + length, bottom, null, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawRight) &#123;</span><br><span class="line">            canvas.saveLayer(right - length, top, right, bottom, null, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Step 3, draw the content</span><br><span class="line">    if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    // Step 4, draw the children</span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    // Step 5, draw the fade effect and restore layers</span><br><span class="line">    final Paint p = scrollabilityCache.paint;</span><br><span class="line">    final Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">    final Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">    if (drawTop) &#123;</span><br><span class="line">        matrix.setScale(1, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (drawBottom) &#123;</span><br><span class="line">        matrix.setScale(1, fadeHeight * bottomFadeStrength);</span><br><span class="line">        matrix.postRotate(180);</span><br><span class="line">        matrix.postTranslate(left, bottom);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (drawLeft) &#123;</span><br><span class="line">        matrix.setScale(1, fadeHeight * leftFadeStrength);</span><br><span class="line">        matrix.postRotate(-90);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (drawRight) &#123;</span><br><span class="line">        matrix.setScale(1, fadeHeight * rightFadeStrength);</span><br><span class="line">        matrix.postRotate(90);</span><br><span class="line">        matrix.postTranslate(right, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">    // Step 6, draw decorations (scrollbars)</span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码片中，我们直接定位到onDrawScrollBars(canvas)方法，找到了这个方法离真相就不远了。上源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;p&gt;Request the drawing of the horizontal and the vertical scrollbar. The</span><br><span class="line"> * scrollbars are painted only if they have been awakened first.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param canvas the canvas on which to draw the scrollbars</span><br><span class="line"> *</span><br><span class="line"> * @see #awakenScrollBars(int)</span><br><span class="line"> */</span><br><span class="line">protected final void onDrawScrollBars(Canvas canvas) &#123;</span><br><span class="line">    // scrollbars are drawn only when the animation is running</span><br><span class="line">    final ScrollabilityCache cache = mScrollCache;</span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line"></span><br><span class="line">        int state = cache.state;</span><br><span class="line"></span><br><span class="line">        if (state == ScrollabilityCache.OFF) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean invalidate = false;</span><br><span class="line"></span><br><span class="line">        if (state == ScrollabilityCache.FADING) &#123;</span><br><span class="line">            // We&apos;re fading -- get our fade interpolation</span><br><span class="line">            if (cache.interpolatorValues == null) &#123;</span><br><span class="line">                cache.interpolatorValues = new float[1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float[] values = cache.interpolatorValues;</span><br><span class="line"></span><br><span class="line">            // Stops the animation if we&apos;re done</span><br><span class="line">            if (cache.scrollBarInterpolator.timeToValues(values) ==</span><br><span class="line">                    Interpolator.Result.FREEZE_END) &#123;</span><br><span class="line">                cache.state = ScrollabilityCache.OFF;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cache.scrollBar.setAlpha(Math.round(values[0]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // This will make the scroll bars inval themselves after</span><br><span class="line">            // drawing. We only want this when we&apos;re fading so that</span><br><span class="line">            // we prevent excessive redraws</span><br><span class="line">            invalidate = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // We&apos;re just on -- but we may have been fading before so</span><br><span class="line">            // reset alpha</span><br><span class="line">            cache.scrollBar.setAlpha(255);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        final int viewFlags = mViewFlags;</span><br><span class="line"></span><br><span class="line">        final boolean drawHorizontalScrollBar =</span><br><span class="line">            (viewFlags &amp; SCROLLBARS_HORIZONTAL) == SCROLLBARS_HORIZONTAL;</span><br><span class="line">        final boolean drawVerticalScrollBar =</span><br><span class="line">            (viewFlags &amp; SCROLLBARS_VERTICAL) == SCROLLBARS_VERTICAL</span><br><span class="line">            &amp;&amp; !isVerticalScrollBarHidden();</span><br><span class="line"></span><br><span class="line">        if (drawVerticalScrollBar || drawHorizontalScrollBar) &#123;</span><br><span class="line">            final int width = mRight - mLeft;</span><br><span class="line">            final int height = mBottom - mTop;</span><br><span class="line"></span><br><span class="line">            final ScrollBarDrawable scrollBar = cache.scrollBar;</span><br><span class="line"></span><br><span class="line">            final int scrollX = mScrollX;</span><br><span class="line">            final int scrollY = mScrollY;</span><br><span class="line">            final int inside = (viewFlags &amp; SCROLLBARS_OUTSIDE_MASK) == 0 ? ~0 : 0;</span><br><span class="line"></span><br><span class="line">            int left, top, right, bottom;</span><br><span class="line"></span><br><span class="line">            if (drawHorizontalScrollBar) &#123;</span><br><span class="line">                int size = scrollBar.getSize(false);</span><br><span class="line">                if (size &lt;= 0) &#123;</span><br><span class="line">                    size = cache.scrollBarSize;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                scrollBar.setParameters(computeHorizontalScrollRange(),</span><br><span class="line">                                        computeHorizontalScrollOffset(),</span><br><span class="line">                                        computeHorizontalScrollExtent(), false);</span><br><span class="line">                final int verticalScrollBarGap = drawVerticalScrollBar ?</span><br><span class="line">                        getVerticalScrollbarWidth() : 0;</span><br><span class="line">                top = scrollY + height - size - (mUserPaddingBottom &amp; inside);</span><br><span class="line">                left = scrollX + (mPaddingLeft &amp; inside);</span><br><span class="line">                right = scrollX + width - (mUserPaddingRight &amp; inside) - verticalScrollBarGap;</span><br><span class="line">                bottom = top + size;</span><br><span class="line">                onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);</span><br><span class="line">                if (invalidate) &#123;</span><br><span class="line">                    invalidate(left, top, right, bottom);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawVerticalScrollBar) &#123;</span><br><span class="line">                int size = scrollBar.getSize(true);</span><br><span class="line">                if (size &lt;= 0) &#123;</span><br><span class="line">                    size = cache.scrollBarSize;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                scrollBar.setParameters(computeVerticalScrollRange(),</span><br><span class="line">                                        computeVerticalScrollOffset(),</span><br><span class="line">                                        computeVerticalScrollExtent(), true);</span><br><span class="line">                switch (mVerticalScrollbarPosition) &#123;</span><br><span class="line">                    default:</span><br><span class="line">                    case SCROLLBAR_POSITION_DEFAULT:</span><br><span class="line">                    case SCROLLBAR_POSITION_RIGHT:</span><br><span class="line">                        left = scrollX + width - size - (mUserPaddingRight &amp; inside);</span><br><span class="line">                        break;</span><br><span class="line">                    case SCROLLBAR_POSITION_LEFT:</span><br><span class="line">                        left = scrollX + (mUserPaddingLeft &amp; inside);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                top = scrollY + (mPaddingTop &amp; inside);</span><br><span class="line">                right = left + size;</span><br><span class="line">                bottom = scrollY + height - (mUserPaddingBottom &amp; inside);</span><br><span class="line">                onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);</span><br><span class="line">                if (invalidate) &#123;</span><br><span class="line">                    invalidate(left, top, right, bottom);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码，我们直接定位到<em>if (drawVerticalScrollBar || drawHorizontalScrollBar)</em>结构语句块。在水平方向滚动与垂直方向滚动语句块中，能够找到一行关键性代码<em>invalidate(left, top, right, bottom)</em>，接着上源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Mark the area defined by the rect (l,t,r,b) as needing to be drawn.</span><br><span class="line"> * The coordinates of the dirty rect are relative to the view.</span><br><span class="line"> * If the view is visible, &#123;@link #onDraw(android.graphics.Canvas)&#125;</span><br><span class="line"> * will be called at some point in the future. This must be called from</span><br><span class="line"> * a UI thread. To call from a non-UI thread, call &#123;@link #postInvalidate()&#125;.</span><br><span class="line"> * @param l the left position of the dirty region</span><br><span class="line"> * @param t the top position of the dirty region</span><br><span class="line"> * @param r the right position of the dirty region</span><br><span class="line"> * @param b the bottom position of the dirty region</span><br><span class="line"> */</span><br><span class="line">public void invalidate(int l, int t, int r, int b) &#123;</span><br><span class="line">    if (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (skipInvalidate()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mPrivateFlags &amp; (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) ||</span><br><span class="line">            (mPrivateFlags &amp; DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID ||</span><br><span class="line">            (mPrivateFlags &amp; INVALIDATED) != INVALIDATED) &#123;</span><br><span class="line">        mPrivateFlags &amp;= ~DRAWING_CACHE_VALID;</span><br><span class="line">        mPrivateFlags |= INVALIDATED;</span><br><span class="line">        mPrivateFlags |= DIRTY;</span><br><span class="line">        final ViewParent p = mParent;</span><br><span class="line">        final AttachInfo ai = mAttachInfo;</span><br><span class="line">        //noinspection PointlessBooleanExpression,ConstantConditions</span><br><span class="line">        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) &#123;</span><br><span class="line">            if (p != null &amp;&amp; ai != null &amp;&amp; ai.mHardwareAccelerated) &#123;</span><br><span class="line">                // fast-track for GL-enabled applications; just invalidate the whole hierarchy</span><br><span class="line">                // with a null dirty rect, which tells the ViewAncestor to redraw everything</span><br><span class="line">                p.invalidateChild(this, null);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">            final int scrollX = mScrollX;</span><br><span class="line">            final int scrollY = mScrollY;</span><br><span class="line">            final Rect tmpr = ai.mTmpInvalRect;</span><br><span class="line">            tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);</span><br><span class="line">            p.invalidateChild(this, tmpr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invalidate(left, top, right, bottom)方法体中，倒数第5行<em>tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY)</em>设置一个view需要绘制的脏矩形，这个方法的传入参数不觉得很奇怪吗？<br><strong>mScrollX和mScrollY都是作为参数的减数（负负得正，负正得负），再结合开头的Android屏幕直角坐标系的概念，通过简单的逻辑分析或者计算就可以证明：当scrollTo()的传入参数为负的时候，view就向坐标轴正方向滚动；当为正的时候，view就向坐标轴负方向滚动。</strong></p>
<p>原文：<a href="http://www.it165.net/pro/html/201404/12506.html" target="_blank" rel="noopener">Android源码角度分析View的scrollBy()和scrollTo()的参数正负问题</a></p>
<p>我的博客网站：<a href="http://huyuxin.top/欢迎大家访问！评论！" target="_blank" rel="noopener">http://huyuxin.top/欢迎大家访问！评论！</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/18/git-three/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/18/git-three/" itemprop="url">Git的查看，对比，撤销，修改，重写</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-18T15:46:36+08:00">
                2016-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>1. 查看与对比
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git show (commit/tag/tree/blog)</span><br><span class="line">git show master^(master~) //查看master下的第一副提交</span><br><span class="line">git show master^2   //查看master下的第二副提交</span><br><span class="line">git show --oneline   //将信息缩减</span><br><span class="line">git show --stat   //输出commit的改变统计信息</span><br><span class="line">git log //查看完整commit 信息</span><br><span class="line">git log -p  //输出每一个commit之间的差异信息</span><br><span class="line">git log --stat //输出每一个commit之间差异的统计信息</span><br><span class="line">git diff  //输出工作区与暂存区之间的差异</span><br><span class="line">git diff --cached //查看暂存区当前与历史的差异</span><br><span class="line">git diff HEAD HEAD~2  //比较两个commit之间的差异</span><br><span class="line">git diff HEAD HEAD~2  master.txt //比较两个commit的某个文件的差异</span><br><span class="line">git diff --color-words //输出具体单词的差异用不同的颜色标出</span><br><span class="line">git diff --word-diff //输出具体单词的差异</span><br></pre></td></tr></table></figure>
<pre><code>2.撤销与修改
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout  //创建和切换分支，还原工作区</span><br><span class="line">git reset    //还原暂存区</span><br><span class="line">git clean     //清除还没添加到暂存区的文件 -n 显示将要删除的文件 -f 删除文件 -df 删除文件和目录</span><br><span class="line">//需要注意的是在 .gitignore 文件中忽略的文件不会被删除，如果需要删除.gitignore忽略的</span><br><span class="line">//文件使用  git clean -n -X(大写)  git clean -f -X(大写) 删除</span><br><span class="line">git revert     //产生一个新的提交来覆盖原来提交产生的修改</span><br><span class="line">git checkout （tag/hash..能代表一个commit的关键字） -- master.txt ///在文件修改还没添加到暂存区时，用暂存区的内容覆盖工作区</span><br></pre></td></tr></table></figure>
<pre><code>3.重写历史纪录
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend //用来产生一个新的提交来替换当前产生的这个提交</span><br><span class="line">git rebase  master（分支名） //产生一个线性的合并提交，产生的commit类似于</span><br><span class="line">//从（分支名）中衍生出来，执行 git rebase --continue 前需要先add</span><br><span class="line">git reflog   //维护了HEAD引用的历史</span><br><span class="line">git reset --hard HEAD@&#123;5&#125;  //还原到HEAD引用历史指向的commit，还原暂存区和工作区</span><br><span class="line">git reset --mixed   // 还原了暂存区并没有还原工作区</span><br><span class="line">git reset --soft （分支名）  //什么都不还原，只是把HEAD指向分支引用</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//SINCE 20160119</span><br></pre></td></tr></table></figure>
<p>我的博客网站：<a href="http://huyuxin95.github.io/" target="_blank" rel="noopener">http://huyuxin.top/</a>欢迎大家访问！评论！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/15/git-two/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huyuxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuxin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/15/git-two/" itemprop="url">关于Git本地分支与合并的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-15T20:57:28+08:00">
                2016-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先需要了解一下几个命令的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch //创建分支</span><br><span class="line">git tag //给固定的commit做标记</span><br><span class="line">git checkout //在固定分支之间进行切换</span><br><span class="line">git stash //切换分支之前保存本地修改</span><br><span class="line">git merge  //合并分支</span><br></pre></td></tr></table></figure>
<p>分支：个人理解就是在当前工作区间向下衍生的一个分支，类似于继承，具有父节点的内容，不同的是，当分支修改时，原来的衍生体（父结点）不受影响。<br>下面拿一个简单的例子说一下就明白了：<br>在master下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git init git_checkout_merge  </span><br><span class="line">cd git_checkout2_merge</span><br><span class="line">vim master.txt     //写入以下内容</span><br><span class="line">Initial commit on master</span><br><span class="line">git add  . //添加到暂存区</span><br><span class="line">git commit –m “Initial commit on master”//提交这次写入</span><br><span class="line">vim master.txt  //再次编辑写入以下内容</span><br><span class="line">Second commit on master</span><br><span class="line">git add .</span><br><span class="line">git commit –m “Second commit on master”</span><br><span class="line">git branch test   //创建一个叫test的分支</span><br><span class="line">git checkout test  //切换到test分支</span><br><span class="line">ls //我们会发现里面有master.txt文件， </span><br><span class="line">vim master.txt //我们会发现他的内容和master下编辑的一样。这就是为什么说类似于继承</span><br><span class="line">Initial commit on test //在后边接着编辑这些内容</span><br><span class="line">touch test.txt  //多创建一个文件更好区分</span><br><span class="line">git add .</span><br><span class="line">git commit –m “Initial commit on test”</span><br></pre></td></tr></table></figure>
<p>如果你返回master或者关闭git再次打开进入master，打开master.txt，你会发现里面只有<br>Initial commit on master<br>Second commit on master</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline  --decorate  --groph  - -all  //查看历史示意图</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160115203514859" alt="groph"></p>
<p>(其中每一次的commit用20位的十六进制SHA-1 Hash值来引用)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config  - -global  - -alias.lol “log --oneline  --decorate  --groph  - -all”</span><br><span class="line">//这样将lol代替log --oneline  --decorate  --groph  - -all，下次输入git lol就可以查看历史示意图</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git tag v1 93fab //后面接上前几位（足以区分的位数）SHA -1 Hash 表示给哪一个commit做标记</span><br><span class="line">git tag v2 //在后面不标明给哪一个commit做标记时是HEAD指向的当前commit如当前的是Second on master</span><br><span class="line">git tag –a “INATIAL_COMMIT”93fa //同样可以做标记，区别在于INATIAL_COMMIT指向的是一个tag对象</span><br><span class="line">git tag //查看所有的tag</span><br><span class="line">git lol //再次查看历史示意图</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160115203711832" alt="git_lol"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout v1 //切换到指定的分支</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20160115203819682" alt="v1"><br><strong>这时系统提示你，你处在于一个detached HEAD状态，HEAD引用直接指向一个commit，而不是一个分支名，再继续工作，切换到别的分支时可能造成数据丢失，同时告诉我们可以通过 git checkout –b &lt;new-branch_name&gt;的方式创建并切换到别的分支，其实git checkout –b &lt;new-branch_name&gt;就是 git branch 和git chechoutl两个命令的组合。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout –b fix_v1  //创建并切换到fix_v1分支</span><br><span class="line">vim master.txt //我们再一次打开编辑并提交</span><br><span class="line">shash1  //写入这些内容（随意）</span><br><span class="line">git add .</span><br><span class="line">git checkout master //如果我们这时候提出切换分支到master</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160115204133852" alt="master1"><br><strong>提示需要先提交这些修改或者将这些修改stash起来</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash save –a “stash1“//切换分支之前保存本地修改 –a表示将暂存区一并保存</span><br><span class="line">git checkout master </span><br><span class="line">/**stash之后如何再次回到之前stash的内容呢？**/</span><br><span class="line">git checkout fix_v1</span><br><span class="line">git stash list //查看stash列表</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160115204303136" alt="stash_list1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash pop  - -index stash@&#123;0&#125;  //用- -index将暂存区一并还原</span><br><span class="line">git stash list //你会发现还原后stash 列表被清空了</span><br><span class="line">git stash apply - -index stash@&#123;0&#125;  //还原并不清空stash列表</span><br><span class="line">git stash drop //删除stash list顶层那项</span><br><span class="line">git stash drop stash@&#123;0&#125; //删除stash list的指定项</span><br><span class="line">git stash clear //清空stash 列表</span><br></pre></td></tr></table></figure>
<h3>本地分支的合并</h3>

<ol>
<li>fast-farword merge<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout –b test_merge</span><br><span class="line">vim master.txt</span><br><span class="line">Initial commit on test_merge //写入内容</span><br><span class="line">git add .</span><br><span class="line">git commit –m “Initial commit on test_merge”</span><br><span class="line">git checkout master</span><br><span class="line">git merge test_merge</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>因为test_merge衍生自master，所以这一次合并只是将HEAD引用指向test_merge</strong><br><img src="http://img.blog.csdn.net/20160115204723452" alt="merge1"></p>
<p></p><h4>合并模型：<br><img src="http://img.blog.csdn.net/20160115204907164" alt="merge2"><p></p>
<ol start="2">
<li>non-fast-farword merge<br><b>注意示意图文件结构</b></li>
</ol>
<p><img src="http://img.blog.csdn.net/20160115205108487" alt="git_lol2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge test  //如果合并内容有冲突，可以取消在这次合并或者编辑冲突文件</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160115205217691" alt="merge_test"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge – abort  //取消在这次合并</span><br><span class="line">vim master.txt    //编辑冲突文件，留下想要的内容</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160115205324287" alt="vi_master.txt"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add master.txt</span><br><span class="line">git commit  //这是系统提示这是merge操作，保存就可以了</span><br></pre></td></tr></table></figure>
<p></p><h4>合并模型：<br><strong>master此时和test并没有衍生关系，git merge test 会先生成一个commit用来承载两个的内容</strong><br><img src="http://img.blog.csdn.net/20160115205535529" alt="merge_test2"><p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//SINCE20160116</span><br></pre></td></tr></table></figure>
<p>我的博客网站：<a href="http://huyuxin95.github.io/" target="_blank" rel="noopener">http://huyuxin.top/</a>欢迎大家访问！评论！</p>
</h4></h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">huyuxin</p>
              <p class="site-description motion-element" itemprop="description">打渔还是晒网,这是一个问题</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/huyuxin95" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:domehuyuxin@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">huyuxin</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
